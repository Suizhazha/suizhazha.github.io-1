<!DOCTYPE html>
<html lang="zh-cn" >
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  
  <meta name="author"
        content="Zeuk"/>

  
  <meta name="description" content="函数是一种特殊的对象 定义一个函数 具名函数 function 函数名(形参1，形参2){ 语句 return 返回值 } 匿名函数（去掉函数名） let a =function(x,y){ return x&#43;y }//也叫函数表达式 note： let a =function fn(x,y){ return x&#43;y } fn(1,2)//会报错，因为fn函数在等"/>
  

  
  
  <meta name="keywords" content="Hugo, theme, zozo"/>
  

  
  <link rel="canonical" href="https://example.com/post/js%E5%87%BD%E6%95%B0/"/>

  

  <title>JS函数 &middot; 无尽光芒</title>

  <link rel="shortcut icon" href="https://example.com/images/favicon.ico"/>
  <link rel="stylesheet" href="https://example.com/css/animate.min.css"/>
  <link rel="stylesheet" href="https://example.com/css/remixicon.css"/>
  <link rel="stylesheet" href="https://example.com/css/zozo.css"/>
  <link rel="stylesheet" href="https://example.com/css/highlight.css"/>

  
  
</head>

<body>
<div class="main animated">
  <div class="nav_container animated fadeInDown">
  <div class="site_nav" id="site_nav">
    <ul>
      
      <li>
        <a href="/">首页</a>
      </li>
      
      <li>
        <a href="/posts/">归档</a>
      </li>
      
      <li>
        <a href="/tags/">标签</a>
      </li>
      
      <li>
        <a href="/about/">关于</a>
      </li>
      
      <li>
        <a href="/about/">About</a>
      </li>
      
    </ul>
  </div>
  <div class="menu_icon">
    <a id="menu_icon"><i class="remixicon-links-line"></i></a>
  </div>
</div>

  <div class="header animated fadeInDown">
  <div class="site_title_container">
    <div class="site_title">
      <h1>
        <a href="https://example.com">
          <span>无尽光芒</span>
          <img src="https://example.com/images/logo.svg"/>
        </a>
      </h1>
    </div>
    <div class="description">
      <p class="sub_title">the site subtitle</p>
      <div class="my_socials">
        
        
        <a href="%20" title="facebook" target="_blank"><i class="remixicon-facebook-fill"></i></a>
        
        
        
        <a href="%20" title="github" target="_blank"><i class="remixicon-github-fill"></i></a>
        
        
        
        <a href="%20" title="instagram" target="_blank"><i class="remixicon-instagram-fill"></i></a>
        
        
        
        <a href="%20" title="twitter" target="_blank"><i class="remixicon-twitter-fill"></i></a>
        
        
        
        <a href="%20" title="weibo" target="_blank"><i class="remixicon-weibo-fill"></i></a>
        
        
        <a href="https://example.com/index.xml" type="application/rss+xml" title="rss" target="_blank"><i class="remixicon-rss-fill"></i></a>
      </div>
    </div>
  </div>
</div>

  <div class="content">
    <div class="post_page">
      <div class="post animated fadeInDown">
        <div class="post_title post_detail_title">
          <h2><a href='/post/js%E5%87%BD%E6%95%B0/'>JS函数</a></h2>
          <span class="date">2020.02.01</span>
        </div>
        <div class="post_content markdown"><p>函数是一种特殊的对象</p>
<h2 id="heading">定义一个函数</h2>
<ul>
<li>具名函数</li>
</ul>
<pre><code>function 函数名(形参1，形参2){
    语句
    return 返回值
}
</code></pre><ul>
<li>匿名函数（去掉函数名）</li>
</ul>
<pre><code>let a =function(x,y){
    return x+y
}//也叫函数表达式
</code></pre><p>note：</p>
<pre><code>let a =function fn(x,y){
    return x+y
}
fn(1,2)//会报错，因为fn函数在等号右边，则作用域范围只在等号右边
</code></pre><ul>
<li>箭头函数</li>
</ul>
<pre><code>let f1 = x =&gt;x*x//箭头左边为输入，右边为输出
f1(9)//输出81
</code></pre><pre><code>let f2 = (x，y) =&gt; x*y//若箭头左边有两个输入参数，需要括号括起来
f2(8,9)//输出72
</code></pre><pre><code>let f3 = (x，y) =&gt; {
    console.log('hi')
    return x*y
}//若箭头右边有多个语句，必须加花括号和return 返回值
</code></pre><pre><code>let f4 = x =&gt;({
    name:x
})//若要在箭头右边直接返回一个对象，需要加括号
</code></pre><ul>
<li>构造函数（很少用）</li>
</ul>
<pre><code>let fn1 = new function('x'，'y',
    'console.log(\'hi\');
    return x*y'
)
</code></pre><p>所有函数都是 Function 构造出来的，包括 Object，Array，Function 都是。</p>
<h2 id="-v-">函数自身 v 函数调用</h2>
<ul>
<li>函数自身</li>
</ul>
<pre><code>let fn = () =&gt;console.log('hi')
fn//没有结果，因为fn没有执行(调用)
</code></pre><ul>
<li>函数调用</li>
</ul>
<pre><code>let fn = () =&gt;console.log('hi')
fn()//打印出hi，有圆括号才是调用
</code></pre><pre><code>let fn = () =&gt;console.log('hi')//fn只保存了匿名函数的地址
let fn2 = fn//地址复制给fn2
fn2()//fn和fn2都是匿名函数的引用而已
</code></pre><h2 id="heading-1">函数的要素</h2>
<ul>
<li>
<p>调用时机</p>
<p>调用时机不同，结果不同</p>
</li>
</ul>
<pre><code>let a = 1
function fn(){
    console.log(a)
}
a = 2
fn()//打印出2
</code></pre><pre><code>let a = 1
function fn(){
  setTimeout(() =&gt; {
    console.log(a)
  },0)
}
fn()
a = 2//先执行完程序，再打印出2
</code></pre><pre><code> let i= 0
 for(i = 0;i &lt; 6;i++){
    setTimeout(() =&gt;{
        console.log(i)
    },0)
 }//打印出6个6，而不是0，1，2，3，4，5
</code></pre><pre><code> for(let i = 0;i &lt; 6;i++){
    setTimeout(() =&gt;{
        console.log(i)
    },0)
 }//打印出0，1，2，3，4，5，因为JS在for和let一起用时会加东西，每次循环会多创建（复制）一个i（迎合新手想法）。
</code></pre><ul>
<li>
<p>作用域</p>
<ul>
<li>全局变量和局部变量</li>
</ul>
<p>在顶级作用域声明的变量就是全局变量，window 的属性是全局变量，其他都局部变量。</p>
<ul>
<li>函数嵌套</li>
</ul>
<pre><code>function f1(){
    let a = 1
    function f2(){
        let a = 2
        console.log(a)
    }
    console.log(a)
    a = 3
    f2()
}
f1()//打印出1，2
</code></pre><p>当多个作用域有同名变量 a，那么查找 a 的声明时，就向上取最近的作用域（就近原则），查找 a 的过程与函数执行无关（静态作用域或词法作用域），但 a 的值和函数执行有关。</p>
</li>
<li>
<p>闭包</p>
<pre><code>  function f1(){
      let a = 1
      function f2(){
          let a = 2
        function f3(){
          console.log(a)
        }
      a = 22
      f3()
  }
  console.log(a)
  a = 100
  f2()
  }
  f1()//打印出1，2
</code></pre><p>如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，如上面的 a 和 f3 组成了闭包。</p>
</li>
<li>
<p>形式参数</p>
</li>
</ul>
<pre><code>function add(x,y){
    return x+y
}//x和y为形参，因为不是实际的参数
add(1,2)//调用add时，1和2为实参，会被赋值给 x，y
</code></pre><pre><code>function add(){
    var x = arguments[]
    var y = arguments[]
    return x+y
}//形参其实可认为是变量声明
</code></pre><ul>
<li>返回值</li>
</ul>
<p>每个函数都有返回值</p>
<pre><code>function hi(){
    console.log('hi')
}
hi()//返回值为undefined，因为没写return
</code></pre><pre><code>function hi(){
    return console.log('hi')
}
hi()//返回值为console.log('hi')的值，即undefined,只是打印了hi
</code></pre><p>函数执行完后才会返回，只有函数才有返回值。</p>
<ul>
<li>调用栈</li>
</ul>
<ol>
<li>
<p>JS 引擎在调用一个函数前，需要把函数所在的环境 push 到一个数组里，数组即为调用栈。</p>
</li>
<li>
<p>等函数执行完后，就会把环境 pop 出来。</p>
</li>
<li>
<p>然后 return 到之前的环境，继续执行后续代码。</p>
<ul>
<li>
<p>递归函数</p>
<ol>
<li>
<p>阶乘</p>
<pre><code>function f(n){
    return n === 1 ? 1 : n*f(n-1)
}
f(100)//压100次栈
</code></pre></li>
<li>
<p>递归的调用栈最长为</p>
<p>Chrome：12578</p>
<p>Firefox：26773</p>
<p>Node：12536</p>
</li>
<li>
<p>爆栈</p>
<p>调用栈中压入得帧过多，程序会崩溃。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>函数提升</li>
</ul>
<pre><code>function fn(){}
</code></pre><p>不管将具名函数声明在哪，都会跑到第一行。</p>
<pre><code>let fn = function(){}//为赋值，右边的匿名函数声明不会提升到第一行
</code></pre><ul>
<li><strong>arguments(箭头函数没有)</strong></li>
</ul>
<p>伪数组</p>
<pre><code>Array.from()//可以将伪数组变成数组
</code></pre><ul>
<li>
<p><strong>this(箭头函数没有)</strong>
如果不给任何条件，this 默认指向 window，如果传的不是对象，JS 会自动封装成对象。</p>
<ul>
<li>传 this</li>
</ul>
<pre><code>fn.call(xxx,1,2,3)//传this或arguments
</code></pre><p>如果非要传数字，不想自动封装成对象</p>
<pre><code>function fn(){
    'use strict'
    console.log('this:'+this)
}
</code></pre><p>this 是一个隐藏参数， arguments 是普通参数。</p>
<ul>
<li>
<p>假如没有 this</p>
<pre><code>let person = {
    name: 'frank',
    sayHi(){
        console.log(`你好，我叫` + person.name)
    }
}
//可以直接保存对象地址的变量获取'name',简称引用
</code></pre><ol>
<li>如果 person 改名了，sayHi 函数就挂了。</li>
<li>或者 sayHi 函数有可能在另一个文件里。</li>
<li>而 JS 中 person.sayHi()会隐式地 person 作为 this 传给 sayHi，方便 sayHi 通过 this 获取 person 对应的对象。</li>
</ol>
</li>
<li>
<p>新手调用法</p>
</li>
</ul>
<pre><code>person.sayHi()
//会自动把person传到函数里，作为this
</code></pre><ul>
<li>老手调用法</li>
</ul>
<pre><code>person.sayHi.call(person)
//要手动把person传到函数里，作为this
</code></pre><p>例如：</p>
<pre><code>function add(x,y){
    return x+y
}
add.call(undefined,1,2)//3
</code></pre><p>第一个参数要作为 this，而原函数没有 this，只能用 undefined 占位，null 也可以。</p>
<p>再如：</p>
<pre><code>Array.prototype.forEach2 = function(fn){
    for(let i=0;i&lt;this.length;i++){
        fn(this[i],i)
    }
}
//因为使用forEach2时总会用arr.forEach2,所以arr就被自动传给了forEach2

array.forEach2.call(array,(item)=&gt;console.log(item))
//1,2,3
array.forEach2.call({0:'a',length： 1 },(item)=&gt;console.log(item))
//this不一定是数组
</code></pre><ul>
<li>this 的两种使用方法</li>
</ul>
<ol>
<li>隐式传递</li>
</ol>
<pre><code>fn(1,2)
obj.child.fn(1)
</code></pre><ol start="2">
<li>显示传递</li>
</ol>
<pre><code>fn.call(undefined,1,2)或fn.apply(undefined,[1,2])
//使用apply需要在参数上加中括号[](需要数组形式)
obj.child.fn.call(obj.child,1)
</code></pre><ul>
<li>绑定 this</li>
</ul>
<ol>
<li>使用.bind 可以让 this 不被改变</li>
</ol>
<pre><code>function f1(p1,p2){
        console.log(this,p1,p2)
    }
    let f2 = f1.bind({name:'frank'})
    //f2就是f1绑定了this之后的函数
    f2()
    //等价于f1.call({name:'frank'})
</code></pre><ol start="2">
<li>.bind 还可以绑定其他参数</li>
</ol>
<pre><code> let f3 = f1.bind({name:'frank'}，'hi')
 f3()//等价于f1.call({name:'frank'},'hi')
</code></pre></li>
<li>
<p>箭头函数（没有 this 和 arguments）</p>
</li>
</ul>
<pre><code>console.log(this)
//window
let a = () =&gt; console.log(this)
//箭头函数的this就是外部window的this，一个普通的变量
a.call(1)//箭头函数的this不能指定，还是外部的this，除非外部this改变
</code></pre><ul>
<li>立即执行函数（现在用的很少）</li>
</ul>
<p>获取局部变量，使用（）立即执行，只需要在匿名函数前加个运算符即可，推荐感叹号！</p>
<pre><code>! function (){
    var a =2
    console.log(a)
} ()//2，+，—可以，1* 也可以，只要加个运算
</code></pre><p>新版 JS 只需要 let 外加{ }即可</p>
<pre><code>{
    let a = 2
    console.log(2)
}//2
</code></pre><h2 id="note">Note:</h2>
<p>function 外有（）时，才会用；分隔开，也是唯一需要加分号的地方。</p>
<pre><code>console.log('hi');
(function (){
    var a =2
    console.log(a)
} ())
</code></pre></div>
        <div class="post_footer">
          
        </div>
      </div>
      
      
    </div>
  </div>
  <a id="back_to_top" href="#" class="back_to_top"><span>△</span></a>
</div>
<footer class="footer">
  <div class="powered_by">
    <a href="https://zeuk.me">Designed by Zeuk,</a>
    <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
  </div>

  <div class="footer_slogan">
    <span>我的精神家园</span>
  </div>
</footer>



<script src="https://example.com/js/jquery-3.3.1.min.js"></script>
<script src="https://example.com/js/zozo.js"></script>
<script src="https://example.com/js/highlight.pack.js"></script>
<link  href="https://example.com/css/fancybox.min.css" rel="stylesheet">
<script src="https://example.com/js/fancybox.min.js"></script>

<script>hljs.initHighlightingOnLoad()</script>


  <script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>






</body>
</html>
