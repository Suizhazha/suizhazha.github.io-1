<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 18 Feb 2020 23:25:11 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>异步和promise</title>
      <link>http://localhost:1313/post/%E5%BC%82%E6%AD%A5%E5%92%8Cpromise/</link>
      <pubDate>Tue, 18 Feb 2020 23:25:11 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%82%E6%AD%A5%E5%92%8Cpromise/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;异步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相关解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若能直接拿到结果，不拿到结果不离开,就是同步。&lt;/p&gt;
&lt;p&gt;例如：去医院挂号，拿到号才能离开窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能直接拿到结果，则是异步。&lt;/p&gt;
&lt;p&gt;例如：去餐厅门口等位，可以拿到号去逛逛，而每 10 分钟去餐厅问一下，为轮询，扫码用微信接收通知，就是回调。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轮询和回调都能拿到结果，只是方式不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以 AJAX 为例，&lt;code&gt;request.send()&lt;/code&gt;后，并不能直接拿到&lt;code&gt;request.response&lt;/code&gt;,必须等到 readyState 变 4 后，浏览器才回头调用(回调)&lt;code&gt;request.onreadystatechange()&lt;/code&gt;，之后才能得到&lt;code&gt;request.response&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回调 callback&lt;/p&gt;
&lt;p&gt;写了一个函数 A，传给另一个函数 B 调用，那么函数 A 就是回调。&lt;/p&gt;
&lt;p&gt;例如：有的时候回调还可以传给一个对象，&lt;code&gt;request.onreadystatechange()&lt;/code&gt;就是写给浏览器调用的，就是让浏览器将来回头调用一下这个函数。&lt;/p&gt;
&lt;p&gt;再例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f1(){}
function f2(fn){
    fn()
}

 f2(f1)
//自己没有调用f1，而f2调用了f1,f1就是回调，f2为自己调用的
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步和回调的关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关联：异步任务在需要在得到结果时通知 JS 来拿结果，让 JS 留一个函数地址给浏览器，异步任务完成时浏览器调用该函数地址即可，同时将结果作为参数传给该函数该函数就是写给浏览器调用的，为回调函数。&lt;/li&gt;
&lt;li&gt;区别：异步任务需要用到回调函数来通知结果，但回调函数不一定只用在异步任务中，回调还可以用到同步任务中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array.forEach(n=&amp;gt;console.log())
//同步回调
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断同步异步&lt;/p&gt;
&lt;p&gt;如果一个函数返回值处于&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setTimeout&lt;/li&gt;
&lt;li&gt;AJAX(即 XMLHttpRequest)&lt;/li&gt;
&lt;li&gt;AddEventListener&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述三个函数内部，那么这个函数就是异步函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;promise&#34;&gt;promise&lt;/h2&gt;
&lt;p&gt;异步任务有两个结果时，可以用一个回调接收两个参数，还可以使用两个回调，但两个方法都有问题，而 promise 正好解决了这些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码更规范。&lt;/li&gt;
&lt;li&gt;容易出现回调地狱，让代码可读性更强。&lt;/li&gt;
&lt;li&gt;方便进行错误处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以简单的 AJAX 的封装为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ajax = (method,url,options) =&amp;gt;{

    //析构赋值，从options里拿出两个变量，后面直接使用
    const {success,fail} = options

    const request = new XMLHttpRequest();
    request.open(method，url);
    request.onreadystatechange = () =&amp;gt;{
    if (request.readyState === 4) {

        //成功就调用 success，失败则调用fail
        if (request.status &amp;lt; 400) {
            success.call(null,request.response)
            }else if(request.status &amp;gt;= 400){
                fail.call(null,request,request.status)
                 }
         }
    }
    request.send()
}//封装完成

ajax(&#39;get&#39;,&#39;/xxx&#39;,{

    //左边是function缩写，右边为箭头函数
    success(response){},fail:(request,status) =&amp;gt;{}
})//调用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 promise 修改：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ajax = (method,url,options) =&amp;gt;{

    //new Promise接收一个函数
    return new Promise((resolve,reject)=&amp;gt;{
        const {success,fail} = options//析构赋值
        const request = new XMLHttpRequest();
        request.open(method，url);
        request.onreadystatechange = () =&amp;gt;{
        if (request.readyState === 4) {

            //成功就调用 resolve，失败则调用reject
            if (request.status &amp;lt; 400) {
                resolve.call(null,request.response)
            }else if(request.status &amp;gt;= 400){
                reject.call(null,request)
                 }
         }
    }
    request.send()
  })
}//封装完成

ajax(&#39;get&#39;,&#39;/xxx&#39;)
    .then((response) =&amp;gt; {}, (request)=&amp;gt;{})
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;虽然也是回调，但不需要记 success，fail。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;then 的第一个参数为 success，第二个参数为 fail。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ajax()返回了一个.then()方法的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;背下&lt;code&gt;return new Promise((resolve,reject)=&amp;gt;{})&lt;/code&gt;以后就理解了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何将一个回调的异步函数改成 promise 异步函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先 &lt;code&gt;return new Promise((resolve,reject)=&amp;gt;{...})&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务成功调用&lt;code&gt;resolve(result)&lt;/code&gt;，任务失败调用&lt;code&gt;reject(error)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;resolve 和 reject 会再去调用成功和失败函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再使用.then(success,fail)传入成功和失败函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;jqueryajax&#34;&gt;jQuery.ajax&lt;/h2&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持更多形式的参数&lt;/li&gt;
&lt;li&gt;支持 Promise&lt;/li&gt;
&lt;li&gt;支持功能更多&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-axios&#34;&gt;但现在很少使用了，专业前端都用 axios&lt;/h3&gt;
&lt;h2 id=&#34;axios&#34;&gt;axios&lt;/h2&gt;
&lt;p&gt;最新的 AJAX 库，抄袭了 jQuery 的封装思路 ，&lt;a href=&#34;https://juejin.im/post/5a9cddb46fb9a028bc2d3c2f&#34;&gt;推荐方方的博客&lt;/a&gt;快速了解 axiosd 的用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码示例&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;axios.get
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;axios 高级用法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;JSON 自动处理&lt;/p&gt;
&lt;p&gt;axios 发现响应的 Content-Type 是 json，就会自动调用 JSON.parse。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求拦截器&lt;/p&gt;
&lt;p&gt;可以在所有请求里加东西，如加查询参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应拦截器&lt;/p&gt;
&lt;p&gt;可以在所有响应里加东西，甚至改内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以生成不同实例（对象）&lt;/p&gt;
&lt;p&gt;不同实例可以设置不同配置，用于复杂场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>关于jQuery</title>
      <link>http://localhost:1313/post/%E5%85%B3%E4%BA%8Ejquery/</link>
      <pubDate>Sat, 15 Feb 2020 22:48:52 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%85%B3%E4%BA%8Ejquery/</guid>
      
        <description>&lt;h2 id=&#34;jquery-&#34;&gt;jQuery 如何获取元素&lt;/h2&gt;
&lt;p&gt;jQuery 的基本设计思想和主要用法，就是&amp;quot;选择某个网页元素，然后对其进行某种操作&amp;rdquo;。这是它区别于其他 Javascript 库的根本特点。&lt;/p&gt;
&lt;p&gt;使用 jQuery 的第一步，往往就是将一个选择表达式，放进构造函数 jQuery()（简写为$），然后得到被选中的元素。&lt;/p&gt;
&lt;p&gt;选择表达式可以是 CSS 选择器：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(document) //选择整个文档对象

$(&#39;#myId&#39;) //选择ID为myId的网页元素

$(&#39;div.myClass&#39;) // 选择class为myClass的div元素

$(&#39;input[name=first]&#39;) // 选择name属性等于first的input元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以是 jQuery 特有的表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;a:first&#39;) //选择网页中第一个a元素

$(&#39;tr:odd&#39;) //选择表格的奇数行

$(&#39;#myForm :input&#39;) // 选择表单中的input元素

$(&#39;div:visible&#39;) //选择可见的div元素

$(&#39;div:gt(2)&#39;) // 选择所有的div元素，除了前三个

$(&#39;div:animated&#39;) // 选择当前处于动画状态的div元素
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading&#34;&gt;改变结果集&lt;/h2&gt;
&lt;p&gt;jQuery 设计思想之二，就是提供各种强大的过滤器，对结果集进行筛选，缩小选择结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).has(&#39;p&#39;); // 选择包含p元素的div元素

$(&#39;div&#39;).not(&#39;.myClass&#39;); //选择class不等于myClass的div元素

$(&#39;div&#39;).filter(&#39;.myClass&#39;); //选择class等于myClass的div元素

$(&#39;div&#39;).first(); //选择第1个div元素

$(&#39;div&#39;).eq(5); //选择第6个div元素

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时候，我们需要从结果集出发，移动到附近的相关元素，jQuery 也提供了在 DOM 树上的移动方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).next(&#39;p&#39;); //选择div元素后面的第一个p元素

$(&#39;div&#39;).parent(); //选择div元素的父元素

$(&#39;div&#39;).closest(&#39;form&#39;); //选择离div最近的那个form父元素

$(&#39;div&#39;).children(); //选择div的所有子元素

$(&#39;div&#39;).siblings(); //选择div的同级元素
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jquery--1&#34;&gt;jQuery 的链式操作&lt;/h2&gt;
&lt;p&gt;jQuery 设计思想之三，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;Hello&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分解开来，就是下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;) //找到div元素

 .find(&#39;h3&#39;) //选择其中的h3元素

 .eq(2) //选择第3个h3元素

 .html(&#39;Hello&#39;); //将它的内容改为Hello
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是 jQuery 最令人称道、最方便的特点。它的原理在于每一步的 jQuery 操作，返回的都是一个 jQuery 对象，所以不同操作可以连在一起。&lt;/p&gt;
&lt;p&gt;jQuery 还提供了.end()方法，使得结果集可以后退一步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;)

 .find(&#39;h3&#39;)

 .eq(2)

 .html(&#39;Hello&#39;)

 .end() //退回到选中所有的h3元素的那一步

 .eq(0) //选中第一个h3元素

 .html(&#39;World&#39;); //将它的内容改为World
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jquery--2&#34;&gt;jQuery 如何创建元素&lt;/h2&gt;
&lt;p&gt;创建新元素的方法非常简单，只要把新元素直接传入 jQuery 的构造函数就行了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;&amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt;&#39;);

　　$(&#39;&amp;lt;li class=&amp;quot;new&amp;quot;&amp;gt;new list item&amp;lt;/li&amp;gt;&#39;);

　　$(&#39;ul&#39;).append(&#39;&amp;lt;li&amp;gt;list item&amp;lt;/li&amp;gt;&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-1&#34;&gt;元素的操作：取值和赋值&lt;/h2&gt;
&lt;p&gt;操作网页元素，最常见的需求是取得它们的值，或者对它们进行赋值。&lt;/p&gt;
&lt;p&gt;jQuery 设计思想之四，就是使用同一个函数，来完成取值（getter）和赋值（setter），即&amp;quot;取值器&amp;quot;与&amp;quot;赋值器&amp;quot;合一。到底是取值还是赋值，由函数的参数决定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;h1&#39;).html(); //html()没有参数，表示取出h1的值
$(&#39;h1&#39;).html(&#39;Hello&#39;); //html()有参数Hello，表示对h1进行赋值

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常见的取值和赋值函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.html() 取出或设置html内容

.text() 取出或设置text内容

.attr() 取出或设置某个属性的值

.width() 取出或设置某个元素的宽度

.height() 取出或设置某个元素的高度

.val() 取出某个表单元素的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的 text 内容）。&lt;/p&gt;
&lt;h2 id=&#34;jquery--3&#34;&gt;jQuery 如何移动元素&lt;/h2&gt;
&lt;p&gt;jQuery 设计思想之五，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。&lt;/p&gt;
&lt;p&gt;假定我们选中了一个 div 元素，需要把它移动到 p 元素后面。&lt;/p&gt;
&lt;p&gt;第一种方法是使用.insertAfter()，把 div 元素移动 p 元素后面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;　$(&#39;div&#39;).insertAfter($(&#39;p&#39;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二种方法是使用.after()，把 p 元素加到 div 元素前面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;　$(&#39;p&#39;).after($(&#39;div&#39;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回 div 元素，第二种方法返回 p 元素。你可以根据需要，选择到底使用哪一种方法。&lt;/p&gt;
&lt;p&gt;使用这种模式的操作方法，一共有四对：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.insertAfter()和.after()：在现存元素的外部，从后面插入元素

.insertBefore()和.before()：在现存元素的外部，从前面插入元素

.appendTo()和.append()：在现存元素的内部，从后面插入元素

.prependTo()和.prepend()：在现存元素的内部，从前面插入元素
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;jquery--4&#34;&gt;jQuery 如何复制、删除元素&lt;/h2&gt;
&lt;p&gt;复制元素使用&lt;code&gt;.clone()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;删除元素使用&lt;code&gt;.remove()和.detach()&lt;/code&gt;。两者的区别在于，前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。&lt;/p&gt;
&lt;p&gt;清空元素内容（但是不删除该元素）使用&lt;code&gt;.empty()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;jquery-httpwwwruanyifengcomblog201107jquery-fundamentalshtml&#34;&gt;本文修改自阮一峰的&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&#34;&gt;《jQuery 设计思想》&lt;/a&gt;。&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>关于DOM</title>
      <link>http://localhost:1313/post/%E5%85%B3%E4%BA%8Edom/</link>
      <pubDate>Sun, 09 Feb 2020 21:02:40 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%85%B3%E4%BA%8Edom/</guid>
      
        <description>&lt;p&gt;DOM:文档对象模型(Document Object Model)&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;获取任意元素，也叫标签&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;window.idxxx或直接idxxx

document.getElementByid(&#39;idxxx&#39;)
//获取与全局属性冲突的id

document.getElementsByTagName(&#39;div&#39;)[0]
//获取所有标签名为div的元素，因为是全部div，需要下标获取单独的div

document.getElementsByClassName(&#39;div&#39;)[0]
//获取class的类名元素

document.querySelector(&#39;#idxxx&#39;)
//获取id

document.querySelector(&#39;div&amp;gt;span:nth-child(2  )&#39;)

document.querySelectorAll(&#39;.red&#39;)[0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;notes：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;兼容 IE 才用 getElement(s)Byxxx&lt;/li&gt;
&lt;li&gt;工作用 querySelector 和 querySelectorAll&lt;/li&gt;
&lt;li&gt;做 demo 直接用 idxxx&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;获取特定元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;document.documentElement
//获取html元素

document.head
//获取head元素

document.body
//获取body元素

window
//获取窗口（窗口不是元素），为添加全局的事件监听

document.all
//获取所有元素，IE发明的，在其他浏览器里为假值，为第六个falsy值
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;node&#34;&gt;Node&lt;/h2&gt;
&lt;p&gt;x.nodeType 可以得到一个数字，其中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素 Element，也叫便签 Tag&lt;/li&gt;
&lt;li&gt;文本 text&lt;/li&gt;
&lt;li&gt;注释 Comment&lt;/li&gt;
&lt;li&gt;文档 Document&lt;/li&gt;
&lt;li&gt;表示文档片段 DocumentFragment&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;heading&#34;&gt;节点的增删改查&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个标签节点&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;let div1 = document.createElement(&#39;div&#39;)
document.createElement(&#39;style&#39;)
document.createElement(&#39;script&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;创建一个文本节点&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;text1 = document.createTextNode(&#39;你好&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;标签里插文本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div1.appendChild(text1)
//Node接口
或者
div1.innerText = &#39;你好&#39;
或者
div1.textContent = &#39;你好&#39;
//Element接口
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;插入页面里
创建的标签默认在 JS 线程中，必须插到 head 或 body 中，才会生效&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;document.body.appendChild(div1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div1.parentNode.removechild(div1)
//从DOM中删除div1，但还在内存中，而div1 = null可彻底移除
或者
div1.remove()
//IE不支持

document.body.appendChild(div1)
//  恢复div1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改属性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div1.className = &#39;red&#39;
//全覆盖
div1.classList.add(&#39;green&#39;)
//新语法，推荐

div1.style.color = &#39;bule&#39;
//修改部分样式

div1.style.backgroundColor = &#39;white&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;改事件处理函数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;div1.onclick = function(x){
    console.log(this)
    console.log(arguments[0])
}
//当用户点击div时，该this为div，arguments[0] 是事件相关的信息组成的对象

div1.addEventListener
//div1.onclick升级版
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;修改内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;text.innerText = &#39;hi&#39;
或者
text.textContent = &#39;hi&#39;
//修改文本内容

div.innerHTML = &#39;&amp;lt;strong&amp;gt;hi&amp;lt;/strong&amp;gt;&#39;
//修改HTML内容

div.innerHTML = &#39;&#39;
div.appendChild(div1)
//修改标签，先清空，再修改
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;修改 parent&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;newParent.appendChild(div)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div1.classList
或者
div1.getAttribute(&#39;class&#39;)
//但两种获取的值可能有所不同
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查 parent&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;node.parentNode
或
node.parentElement
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;查 child&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;node.childNodes
//包括文本节点
或
node.children
//不包括文本节点，推荐
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;查兄弟&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;node.perentNode.children
//需要利用遍历排除自己
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;查看老大老幺&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;node.firstChild
node.lastChild
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;查看上一个哥哥或下一个弟弟&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;node.previousSibling
node.nextSibling
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;遍历一个 div 中所有元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;travel = (node, fn) =&amp;gt; {
    fn(node)
    if(node.children){
        for(let i = 0;i&amp;lt;node.children.length;i++){
            travel(node.children[i],fn)
        }
    }
}
travel( div1,(node) =&amp;gt; console.log(node) )
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>算法入门下</title>
      <link>http://localhost:1313/post/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E4%B8%8B/</link>
      <pubDate>Thu, 06 Feb 2020 22:33:46 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%E4%B8%8B/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;选择排序(续)&lt;/h2&gt;
&lt;h3 id=&#34;-minindex&#34;&gt;重写 minIndex&lt;/h3&gt;
&lt;p&gt;循环思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let minIndex = (numbers) =&amp;gt; {
    let index = 0
    for(let i = 1;i &amp;lt; numbers.length; i++){
        if(numbers[i] &amp;lt; numbers[index]){
            index = 1
        }
    }
    return index
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-sort&#34;&gt;重写 sort&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;let sort = (numbers) =&amp;gt; {
    for(let i=0;i&amp;lt;numbers.length - 1;i++){
    console.log(`----`)
    console.log(`i: ${i}`)
    let index = minIndex(numbers.slice(i)) + i
    //若循环已经找到第一个最小的数字，则之后再找最小时，忽略第一个
    console.log(`index: ${index}`)
    console.log(`min: ${numbers[index]}`)
    if(index!==i){
    swap(number,index,i)
    console.log(`swap ${index}: ${i}`)
    console.log(numbers)
    }
  }
  return numbers
}

let minIndex = (numbers) =&amp;gt; {
    let index = 0
    for(let i = 1;i &amp;lt; numbers.length; i++){
        if(numbers[i] &amp;lt; numbers[index]){
            index = 1
        }
    }
    return index
}

let swap = (array, i, j) =&amp;gt; {
    let temp = array[i]
    array[i] = array[j]
    array[j] = temp
}//array为对象，传参复制地址
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-1&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;递归思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let quickSort = arr =&amp;gt; {
    if(arr.length &amp;lt;= 1){ return arr }
    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex, 1)[0]
    let left = []
    let right = []
    for (let i =0;i &amp;lt; arr.length; i++){
        if  (arr[i] &amp;lt; pivot){
            left.push(arr[i])
        } else {
            right.push(arr[i])
        }
    }
    return quickSort(left).concat([povit],quickSort(right) )
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-2&#34;&gt;归并排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let mergeSort = arr =&amp;gt;{
  let k = arr.length
  if(k===1){return arr}
  let left = arr.slice(0, Math.floor(k/2))
  let right = arr.slice(Math.floor(k/2))
  return merge(mergeSort(left), mergeSort(right))
}
let merge = (a, b) =&amp;gt; {
  if(a.length === 0) return b
  if(b.length === 0) return a
  return a[0] &amp;gt; b[0] ?
     [b[0]].concat(merge(a, b.slice(1))) :
     [a[0]].concat(merge(a.slice(1), b))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-3&#34;&gt;计数排序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let countSort = arr =&amp;gt;{
  let hashTable = {}, max = 0, result = []
  for(let i=0; i&amp;lt;arr.length; i++){ // 遍历数组
    if(!(arr[i] in hashTable)){
      hashTable[arr[i]] = 1
    }else{
      hashTable[arr[i]] += 1
    }
    if(arr[i] &amp;gt; max) {max = arr[i]}
  }
  for(let j=0; j&amp;lt;=max; j++){ // 遍历哈希表
    if(j in hashTable){
      for(let i = 0; i&amp;lt;hashTable[j]; i++){
        result.push(j)
      }
    }
  }
  return result
}

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>算法入门上</title>
      <link>http://localhost:1313/post/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 04 Feb 2020 22:38:49 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;查找两个数中较大的&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let maxOf2 = (numbers) =&amp;gt;{
    if(numbers[0] &amp;lt; number[1]){
        return number[1]
    }else {
        return number[0]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;优化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let maxOf2 = numbers =&amp;gt;
    number[0] &amp;lt; number[1]
        ?number[1]:number[0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再优化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let maxOf2 = ([a,b]) =&amp;gt; a &amp;lt; b ? b : a
//析构赋值
maxOf2([1,2])//2,新手调用法
maxOf2.call(null,[1,3])//3,老手调用法
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JS 内置了 Math.max 的 API&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.max(2,3)//3
Math.max.call(null,2,3)//3
Math.max.apply(null,[2,3])//3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;除了 Math 是对象，其他首字母大写的都是构造函数！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;查找三个数字中最大的&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let maxOf3 = ([a,b,c]) =&amp;gt; {
    return maxOf2([ a, maxOf2([b,c]) ])
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;推理出 4 个数中最大的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let maxOf4 = ([a,b,c，d]) =&amp;gt; {
    return maxOf2([ a, maxOf3([b,c,d]) ])
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-2&#34;&gt;查找任意数组中的最大值&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;let max =(numbers) =&amp;gt; {
  if(number.length &amp;gt; 2){
    return max(
        [ number[0],max(number.slice(1)) ]
    )
  }else{
      return Math.max.apply(null, numbers)
      //max不接收数组,接收数字
    }
  }//递归
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;函数不停的调用自己，每次调用的参数不同&lt;/li&gt;
&lt;li&gt;当满足某个简单条件时，则实现一个简单的调用&lt;/li&gt;
&lt;li&gt;最终算出结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;排序算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归实现&lt;/li&gt;
&lt;li&gt;循环实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择排序(递归)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;长度为 2 的数组排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let sort2 = ([a,b]) =&amp;gt; {
    if (a  &amp;gt; b){
        return [a, b]
    }else{
        return [b,a]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;优化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let sort2 = ([a,b]) =&amp;gt;
    a &amp;lt; b ? [a,b] : [b,a]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;长度为 3 的数组排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let sort3 = (numbers) =&amp;gt; {
    let index = minIndex(numbers)
    let min = numbers[index]
    number.splice(index,1)
    //从numbers中删掉min
    return [min],concat(sort2(numbers))
}

let minIndex = (numbers) =&amp;gt;
    numbers.indexOf( min(numbers) )
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;任意长度的数组排序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let sort = (numbers) =&amp;gt; {
   if(numbers.length &amp;gt; 2){
    let index = minIndex(numbers)
    let min = numbers[index]
    number.splice(index,1)
    //从numbers中删掉min
    return [min],concat( sort(numbers) )
}else{
    return numbers[0]&amp;lt;numbers[1]
    : numbers ? numbers.reverse()
}

let minIndex = (numbers) =&amp;gt;
    numbers.indexOf( min(numbers) )
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JS运算符</title>
      <link>http://localhost:1313/post/js%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 03 Feb 2020 21:00:25 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;算数运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;number 运算&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;加减乘除&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;余数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;-1 % 7的余数为 -1//提个负号，加 1 % 7的余数
//正常数学-1 % 7=== 6 % 7 的余数
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;指数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;7 ** 2 //49
7 ** 3 //343
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;自增自减&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;a++//a在前，值为前
++a//a在后，值为后
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;求值运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var a = 8
+a
//8,＋号后面取任何数，都是取这个数的值

var a = - 8
+a
//-8
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;负数运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var a = - 8
-a
//8,正数变负数，负数变正数
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;string-&#34;&gt;string 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;连接运算&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&#39;1&#39;+&#39;2&#39;
//&amp;quot;12&amp;quot;,只支持加号
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;js 独有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 +&#39;2&#39;
//&amp;quot;12&amp;quot;,JS会将数字变成字符串再连接

&#39;2&#39; - 1
// 1 ,字符串不支持减号，JS会将字符串变成数字再运算
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;note：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;少写自增自减&lt;/li&gt;
&lt;li&gt;不同类型不要加起来&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;比较运算符&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;==&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/2/3/1700aa45bb630e62?w=344&amp;amp;h=315&amp;amp;f=png&amp;amp;s=78224&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 == []
0 == &#39;0&#39;
0 == &#39;\t&#39;
//ture，但右边三个互不相等
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;永远不要使用 == ，==自作聪明会自动类型转换，使用 === 。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;===&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本类型看值是否相等&lt;/li&gt;
&lt;li&gt;对象看地址是否相等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;note:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NaN != NaN
[]===[]
//false,对象看地址
{}==={}
//false
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-2&#34;&gt;布尔运算符&lt;/h2&gt;
&lt;p&gt;|| &amp;amp;&amp;amp; ！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console&amp;amp;&amp;amp;console.log&amp;amp;&amp;amp;console.log(&#39;hi&#39;)
//防止console被改写，不存在console报错

a = a || 100
//100,a的保底值，可能有bug

function add(n =0){
    return n+1
}
//最新语法，保底值
add(null)
//1
add(undefined)
//1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-3&#34;&gt;二进制运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;或 | 与 &amp;amp; 否 ~(只能二进制运算)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;0b11
//3

0b1111 | 0b1010
//15，结果会以十进制展示
(0b1111 | 0b1010).toString(2)
//&amp;quot;1111&amp;quot;,二进制展示，两位比较都为0，结果为0，否则为1

(0b1111 &amp;amp; 0b1010).toString(2)
//&amp;quot;1010&amp;quot;两位比较都为1，结果为1，否则为0

(~0b1111).toString(2)
//&amp;quot;-10000&amp;quot;自动补一个1
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;异或 ^&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个位相同，则结果为 0，否则为 1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(0b1111 ^ 0b1010).toString(2)
//&amp;quot;101&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;左移右移 &amp;laquo; &amp;raquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;(0b0010 &amp;gt;&amp;gt; 1 ).toString(2)
// &amp;quot;1&amp;quot;
(0b0010 &amp;lt;&amp;lt; 1 ).toString(2)
// &amp;quot;100&amp;quot;
(0b0011 &amp;gt;&amp;gt; 1 ).toString(2)
// &amp;quot;1&amp;quot; “吃掉”最右边的 1
(0b0011 &amp;lt;&amp;lt; 1 ).toString(2)
// &amp;quot;110&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;头部补零 的右移运算符 &amp;raquo;&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;(0b1011 &amp;gt;&amp;gt;&amp;gt; 1 ).toString(2)
// &amp;quot;101&amp;quot;,正数的右移和头部补零的右移完全一样
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading-4&#34;&gt;使用与运算符判断奇偶&lt;/h3&gt;
&lt;p&gt;奇数 &amp;amp; 1 = 1
偶数 &amp;amp; 1 = 0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7 &amp;amp; 0b001
// 1 奇数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;heading-5&#34;&gt;使用~,&amp;raquo;,&amp;laquo;,&amp;raquo;&amp;gt;,|取整&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;console.log(~~ 6.83)//6
console.log(6.83 &amp;gt;&amp;gt; 0)//6
console.log(6.83 &amp;lt;&amp;lt; 0)//6
console.log(6.83 | 0)//6
console.log(6.83 &amp;gt;&amp;gt;&amp;gt; 0)//6
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;-ab-&#34;&gt;使用^交换 a,b 的值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;最新的语法
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JS函数</title>
      <link>http://localhost:1313/post/js%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 01 Feb 2020 23:57:11 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%87%BD%E6%95%B0/</guid>
      
        <description>&lt;p&gt;函数是一种特殊的对象&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;定义一个函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;具名函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function 函数名(形参1，形参2){
    语句
    return 返回值
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;匿名函数（去掉函数名）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let a =function(x,y){
    return x+y
}//也叫函数表达式
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;note：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a =function fn(x,y){
    return x+y
}
fn(1,2)//会报错，因为fn函数在等号右边，则作用域范围只在等号右边
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let f1 = x =&amp;gt;x*x//箭头左边为输入，右边为输出
f1(9)//输出81
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let f2 = (x，y) =&amp;gt; x*y//若箭头左边有两个输入参数，需要括号括起来
f2(8,9)//输出72
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let f3 = (x，y) =&amp;gt; {
    console.log(&#39;hi&#39;)
    return x*y
}//若箭头右边有多个语句，必须加花括号和return 返回值
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let f4 = x =&amp;gt;({
    name:x
})//若要在箭头右边直接返回一个对象，需要加括号
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;构造函数（很少用）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let fn1 = new function(&#39;x&#39;，&#39;y&#39;,
    &#39;console.log(\&#39;hi\&#39;);
    return x*y&#39;
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有函数都是 Function 构造出来的，包括 Object，Array，Function 都是。&lt;/p&gt;
&lt;h2 id=&#34;-v-&#34;&gt;函数自身 v 函数调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数自身&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let fn = () =&amp;gt;console.log(&#39;hi&#39;)
fn//没有结果，因为fn没有执行(调用)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let fn = () =&amp;gt;console.log(&#39;hi&#39;)
fn()//打印出hi，有圆括号才是调用
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let fn = () =&amp;gt;console.log(&#39;hi&#39;)//fn只保存了匿名函数的地址
let fn2 = fn//地址复制给fn2
fn2()//fn和fn2都是匿名函数的引用而已
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;heading-1&#34;&gt;函数的要素&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调用时机&lt;/p&gt;
&lt;p&gt;调用时机不同，结果不同&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let a = 1
function fn(){
    console.log(a)
}
a = 2
fn()//打印出2
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let a = 1
function fn(){
  setTimeout(() =&amp;gt; {
    console.log(a)
  },0)
}
fn()
a = 2//先执行完程序，再打印出2
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt; let i= 0
 for(i = 0;i &amp;lt; 6;i++){
    setTimeout(() =&amp;gt;{
        console.log(i)
    },0)
 }//打印出6个6，而不是0，1，2，3，4，5
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt; for(let i = 0;i &amp;lt; 6;i++){
    setTimeout(() =&amp;gt;{
        console.log(i)
    },0)
 }//打印出0，1，2，3，4，5，因为JS在for和let一起用时会加东西，每次循环会多创建（复制）一个i（迎合新手想法）。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局变量和局部变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在顶级作用域声明的变量就是全局变量，window 的属性是全局变量，其他都局部变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function f1(){
    let a = 1
    function f2(){
        let a = 2
        console.log(a)
    }
    console.log(a)
    a = 3
    f2()
}
f1()//打印出1，2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当多个作用域有同名变量 a，那么查找 a 的声明时，就向上取最近的作用域（就近原则），查找 a 的过程与函数执行无关（静态作用域或词法作用域），但 a 的值和函数执行有关。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;闭包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  function f1(){
      let a = 1
      function f2(){
          let a = 2
        function f3(){
          console.log(a)
        }
      a = 22
      f3()
  }
  console.log(a)
  a = 100
  f2()
  }
  f1()//打印出1，2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，如上面的 a 和 f3 组成了闭包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形式参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function add(x,y){
    return x+y
}//x和y为形参，因为不是实际的参数
add(1,2)//调用add时，1和2为实参，会被赋值给 x，y
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;function add(){
    var x = arguments[]
    var y = arguments[]
    return x+y
}//形参其实可认为是变量声明
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个函数都有返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function hi(){
    console.log(&#39;hi&#39;)
}
hi()//返回值为undefined，因为没写return
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;function hi(){
    return console.log(&#39;hi&#39;)
}
hi()//返回值为console.log(&#39;hi&#39;)的值，即undefined,只是打印了hi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数执行完后才会返回，只有函数才有返回值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用栈&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;JS 引擎在调用一个函数前，需要把函数所在的环境 push 到一个数组里，数组即为调用栈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等函数执行完后，就会把环境 pop 出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后 return 到之前的环境，继续执行后续代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;递归函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阶乘&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(n){
    return n === 1 ? 1 : n*f(n-1)
}
f(100)//压100次栈
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归的调用栈最长为&lt;/p&gt;
&lt;p&gt;Chrome：12578&lt;/p&gt;
&lt;p&gt;Firefox：26773&lt;/p&gt;
&lt;p&gt;Node：12536&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爆栈&lt;/p&gt;
&lt;p&gt;调用栈中压入得帧过多，程序会崩溃。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;函数提升&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;function fn(){}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不管将具名函数声明在哪，都会跑到第一行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let fn = function(){}//为赋值，右边的匿名函数声明不会提升到第一行
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;arguments(箭头函数没有)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;伪数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.from()//可以将伪数组变成数组
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;this(箭头函数没有)&lt;/strong&gt;
如果不给任何条件，this 默认指向 window，如果传的不是对象，JS 会自动封装成对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传 this&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;fn.call(xxx,1,2,3)//传this或arguments
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果非要传数字，不想自动封装成对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn(){
    &#39;use strict&#39;
    console.log(&#39;this:&#39;+this)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;this 是一个隐藏参数， arguments 是普通参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假如没有 this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let person = {
    name: &#39;frank&#39;,
    sayHi(){
        console.log(`你好，我叫` + person.name)
    }
}
//可以直接保存对象地址的变量获取&#39;name&#39;,简称引用
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;如果 person 改名了，sayHi 函数就挂了。&lt;/li&gt;
&lt;li&gt;或者 sayHi 函数有可能在另一个文件里。&lt;/li&gt;
&lt;li&gt;而 JS 中 person.sayHi()会隐式地 person 作为 this 传给 sayHi，方便 sayHi 通过 this 获取 person 对应的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新手调用法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;person.sayHi()
//会自动把person传到函数里，作为this
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;老手调用法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;person.sayHi.call(person)
//要手动把person传到函数里，作为this
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function add(x,y){
    return x+y
}
add.call(undefined,1,2)//3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个参数要作为 this，而原函数没有 this，只能用 undefined 占位，null 也可以。&lt;/p&gt;
&lt;p&gt;再如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.prototype.forEach2 = function(fn){
    for(let i=0;i&amp;lt;this.length;i++){
        fn(this[i],i)
    }
}
//因为使用forEach2时总会用arr.forEach2,所以arr就被自动传给了forEach2

array.forEach2.call(array,(item)=&amp;gt;console.log(item))
//1,2,3
array.forEach2.call({0:&#39;a&#39;,length： 1 },(item)=&amp;gt;console.log(item))
//this不一定是数组
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;this 的两种使用方法&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;隐式传递&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;fn(1,2)
obj.child.fn(1)
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;显示传递&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;fn.call(undefined,1,2)或fn.apply(undefined,[1,2])
//使用apply需要在参数上加中括号[](需要数组形式)
obj.child.fn.call(obj.child,1)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;绑定 this&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;使用.bind 可以让 this 不被改变&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;function f1(p1,p2){
        console.log(this,p1,p2)
    }
    let f2 = f1.bind({name:&#39;frank&#39;})
    //f2就是f1绑定了this之后的函数
    f2()
    //等价于f1.call({name:&#39;frank&#39;})
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;.bind 还可以绑定其他参数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt; let f3 = f1.bind({name:&#39;frank&#39;}，&#39;hi&#39;)
 f3()//等价于f1.call({name:&#39;frank&#39;},&#39;hi&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;箭头函数（没有 this 和 arguments）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;console.log(this)
//window
let a = () =&amp;gt; console.log(this)
//箭头函数的this就是外部window的this，一个普通的变量
a.call(1)//箭头函数的this不能指定，还是外部的this，除非外部this改变
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;立即执行函数（现在用的很少）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;获取局部变量，使用（）立即执行，只需要在匿名函数前加个运算符即可，推荐感叹号！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;! function (){
    var a =2
    console.log(a)
} ()//2，+，—可以，1* 也可以，只要加个运算
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;新版 JS 只需要 let 外加{ }即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    let a = 2
    console.log(2)
}//2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;note&#34;&gt;Note:&lt;/h2&gt;
&lt;p&gt;function 外有（）时，才会用；分隔开，也是唯一需要加分号的地方。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&#39;hi&#39;);
(function (){
    var a =2
    console.log(a)
} ())
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JS数组</title>
      <link>http://localhost:1313/post/js%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 31 Jan 2020 15:10:34 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E6%95%B0%E7%BB%84/</guid>
      
        <description>&lt;h2 id=&#34;js-&#34;&gt;JS 数组&lt;/h2&gt;
&lt;p&gt;一种特殊的对象，JS 其实没有真正的数组，只是用对象模拟数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素的数据类型可以不同。&lt;/li&gt;
&lt;li&gt;内存不一定是连续的（因为对象是随机存储的）。&lt;/li&gt;
&lt;li&gt;不能通过数字下标，而是通过字符串下标。&lt;/li&gt;
&lt;li&gt;意味着数组可以有任何 key。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading&#34;&gt;创建数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;新建&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr=[1,2,3]
let arr=new Array(1,2,3)
let arr=new Array(3)//数组长度为3
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;转化&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr=&#39;1,2,3&#39;
arr.split(&#39;,&#39;)//使用字符串创建数组
或
let arr=&#39;123&#39;
arr.split(&#39;&#39;)

Array.from(&#39;123&#39;)//存在下标和length的对象，可以转化为数组
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;伪数组&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let divList=document.querySelector(&#39;div&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;notes：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;伪数组的原型链中没有数组的原型。&lt;/li&gt;
&lt;li&gt;没有数组共用属性的数组就是伪数组。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;合并两个数组&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr1.concat(arr2)//返回新的数组，不会影响arr1，arr2的值
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;截取数组的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr1.slice(1)//从第二个元素开始截取，不会改变原数组arr1的值
arr2.slice(0)//全部截取
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;note：JS 只提供浅拷贝&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;数组中元素的增删改查&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;删除元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跟删除对象一样的方式，不推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
delete arr[&#39;0&#39;]//数组长度不会变，JS设计问题
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let arr=[1,2,3,4,5]
arr.length=1//修改length可以删除元素，但不要随便修改length
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;正规删除元素的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;删除头部元素
arr.shift()// arr值会修改，并返回被删元素
删除尾部元素
arr.pop()//arr值会修改，并返回被删元素
删除中间的元素
arr.slice(2,1)//从第三个元素开始，删除一个元素
arr.slice(2,1,&#39;x&#39;)//再删除位置添加一个&#39;x&#39;
arr.slice(2,1,&#39;x&#39;&#39;y&#39;)//再删除位置添加一个&#39;x&#39;&#39;y&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看所有元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看数字（字符串）属性名和属性值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for(let i=0;i&amp;lt;arr.length;i++){
    console.log(`${i} : ${arr[i]}`)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;arr.forEach(function(item,index){
    console.log(`${index}: ${item}`)
} )//forEach/map等原型上的函数
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;查看单个属性&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr=[a,b,c]
arr[1]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;索引越界&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr[arr.length]===undefined
arr[-1]===undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;越界常见报错：Cannot read property &amp;lsquo;toString&amp;rsquo; of undefined
意思就是你读取了 undefined 的 toString 属性，不是 toString 的 undefined。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看元素是否存在数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.indexOf(111)//存在返回索引，否则返回-1
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用条件查找元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.find(item=&amp;gt;item%2===0)//找第一个偶数
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用条件查找元素的索引&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.findIndex(item=&amp;gt;item%2===0)//找第一个偶数的索引
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增加数组中的元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在尾部加元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.push(newItem)
arr.push(item1,item2)//都是修改arr，返回新长度
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在头部加元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.unshift(newItem)
arr.unshift(item1,item2)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在中间加元素和改元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.splice(index,0,&#39;x&#39;)
arr.splice(index,0,&#39;x&#39;,&#39;y&#39;)//在index后添加&#39;x&#39;&#39;y&#39;元素

arr.splice(index,1,&#39;x&#39;)//删除index，添加&#39;x&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;反转顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.reverse()//修改了原数组
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;note-var-s--abcde&#34;&gt;note：如何将 var s = &amp;lsquo;abcde&#39;反转&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. s.split(&#39;&#39;)
2. s.split(&#39;&#39;).reverse
3. s.split(&#39;&#39;).reverse.join(&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;自定义排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;arr.sort()//默认按从小到大顺序排序
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若数值大的需要排在前面，则需要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr.sort(function(a,b){
    if(a&amp;gt;b){
        return -1
    }else if(a===b){
        return 0
    }else{
        return 1
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以简写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arr.sort((a,b) =&amp;gt; {
    return a - b
})
或
arr.sort((a,b) =&amp;gt; a - b)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;数组变换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1,2,3,4,5]
arr.map(item =&amp;gt; item*item)//返回每个元素的平方，不会改变原数组
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1,2,3,4,5]
arr.filter(item =&amp;gt; item %2 ===0 //返回偶数，不会改变原数组
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;reduce：数组中最强大的 API&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1,2,3,4,5]
arr.reduce((sum,item) =&amp;gt;{return sum+item },0)//返回15，不会改变原数组
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;let arr = [1,2,3,4,5]
arr.reduce((result,item) =&amp;gt;{ return result.concat(item*item) },[])//利用reduce返回元素平方，不会改变原数组
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;arr.reduce((result,item) =&amp;gt;{
  if(item %2 === 1){
      return result
  }else{
      return result.concat(item)
  }
 },[])//利用reduce返回偶数，不会改变原数组
或者
arr.reduce((result,item) =&amp;gt;{
  item %2 === 1  ？
    result
    ：
    return result.concat(item)
  ,[])
 或者
 let arr = [1,2,3,4,5]
arr.reduce((result,item) =&amp;gt;
    result.concat(item %2 === 1 ? [] :item)
,[])//炫技！！！
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JavaScript对象</title>
      <link>http://localhost:1313/post/javascript%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 27 Jan 2020 21:13:53 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E5%AF%B9%E8%B1%A1/</guid>
      
        <description>&lt;h2 id=&#34;-object&#34;&gt;对象 object&lt;/h2&gt;
&lt;p&gt;唯一复杂数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无序的数据集合&lt;/li&gt;
&lt;li&gt;键值对（name 是键，frank 是值，组成了一对键值对）的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. let obj={&#39;name&#39;:&#39;frank&#39;,&#39;age&#39;:18} //name，age 只能是字符串，就算引号删掉，也还是字符串

2. let obj=new Object({name&#39;:&#39;frank&#39;}) //正规写法，上面是简单写法

3. console.log({&#39;name&#39;:&#39;frank&#39;,&#39;age&#39;:18}) //匿名字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notes：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键名 key 是字符串，不是标识符（标识符不能以数字开头的，键名可以用数字），可以包含任意字符（空字符串、空格字符串也合法）&lt;/li&gt;
&lt;li&gt;引号可省略，省略之后只能写标识符，但中文、空格需要加引号。&lt;/li&gt;
&lt;li&gt;就算引号省略了，键名也还是字符串！&lt;/li&gt;
&lt;li&gt;每一个 key 都是对象的属性名，name 是属性名，每一个 value 都是对象的属性值，frank 是属性值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;奇怪的属性名&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有属性名会自动变成字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; let obj={
   1:&#39;a&#39;,
   3.2:&#39;b&#39;,
   1e2:true,
   1e-2:true,
   .234:true,
   0xFF:true
 }
 Object.key(obj)
 =&amp;gt;[&amp;quot;1&amp;quot;,&amp;quot;100&amp;quot;,&amp;quot;255&amp;quot;,&amp;quot;3.2&amp;quot;,&amp;quot;0.01&amp;quot;,&amp;quot;0.234&amp;quot;]
 //Object.key(obj)为打出所有的键名（key）
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;变量做属性名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/26/16fe22aca74fd8bd?w=323&amp;amp;h=416&amp;amp;f=png&amp;amp;s=41500&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;notes&#34;&gt;notes：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;使用变量的值作为 key，需要加[]。&lt;/li&gt;
&lt;li&gt;不加[]的属性名会自动变成字符串。&lt;/li&gt;
&lt;li&gt;值如果不是字符串，则自动变成字符串。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading&#34;&gt;对象的隐藏属性：&lt;/h2&gt;
&lt;p&gt;JS 中每一个对象都有一个隐藏属性,这个隐藏属性储存着其共有属性组成的对象的地址,这个共有属性组成的对象叫做原型,即隐藏属性储存着原型的地址。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/26/16fe2336d606fb73?w=516&amp;amp;h=470&amp;amp;f=png&amp;amp;s=146450&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以使用 obj 访问那些共有属性:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/26/16fe2346a47fe9af?w=292&amp;amp;h=220&amp;amp;f=png&amp;amp;s=31287&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;note：除了字符串，，symbol 也能做属性名，但目前用不到，迭代是会用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a=symbol()
let obj={[a]:&#39;Hello&#39;}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;增删改查&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;删除属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delete obj.xxx 或 delete obj[&amp;lsquo;xxx&amp;rsquo;]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;区分属性值为 undefined 和不含属性名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;&#39;属性名&#39; in obj&lt;/code&gt;可以查看不管是自身还是共有的属性是否存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete 只能删属性，不能删除对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 查看自身所有属性
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object.keys(obj)&lt;/code&gt; - 查看自身所有值：
&lt;code&gt;Object.values(obj)&lt;/code&gt; - 查看自身所有属性和值：
&lt;code&gt;obj&lt;/code&gt;或&lt;code&gt;Object.entries(obj)&lt;/code&gt; - 查看自身属性和共有属性
&lt;code&gt;console.dir(obj)&lt;/code&gt; - 也可依次用出 &lt;code&gt;obj.__xxx__&lt;/code&gt;查看共有属性 - 查看单个属性： 1. 中括号语法：&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt; 2. 点语法：&lt;code&gt;obj.key&lt;/code&gt; 3. 错误语法：&lt;code&gt;obj[key] // 变量 key 值一般不为&#39;key&#39;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Q：如何判断一个属性是自身的还是共有的

A：obj.hasOwnProperty(&#39;toString&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;note：对象的原型也是对象，而原型（对象的根）的原型，值为 null。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改或增加属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let obj={name:&#39;frank&#39;} // name是字符串
obj.name=&#39;frank&#39; // name是字符串
obj[&#39;name&#39;]=&#39;frank&#39;
obj[&#39;na&#39;+&#39;me&#39;]=&#39;frank&#39;
let key=&#39;name&#39;;obj[key]=&#39;frank&#39;
let key=&#39;name&#39;;obj.key=&#39;frank&#39; // 错误，因为obj.key等价于obj[&#39;key&#39;]
obj[name]=&#39;frank&#39; // 错误，因为name值不确定
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;批量赋值(ES6 新出的 API)&lt;br&gt;
&lt;code&gt;Object.assign(obj,{age:18,gender:&#39;man&#39;})&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改或者增加共有属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无法通过自身修改或增加共有属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let obj={},obj2={} // 共有 toString
obj.toString=&#39;xxx&#39;//只会在改 obj 自身属性
obj2.toString //还是在原型上
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若非要修改或增加原型上的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;obj.__proto__.toString=&#39;xxx&#39; // 不推荐用__proto__
Object.prototype.toString=&#39;xxx&#39;
//一般来说，永远不要修改原型，会引起很多问题，比如代码崩溃，代码异常
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;修改隐藏属性:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不推荐使用 proto&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let obj={name:&#39;frank&#39;}
let obj2={name:&#39;jack&#39;}
let common={kind:&#39;human&#39;}
obj.__proto__=common
obj2.__proto__=common
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;推荐使用 Object.create&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let obj=Object.create(common)
obj.name=&#39;frank&#39;
let obj=Object.create(common)
obj2.name=&#39;suixin&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JS变量声明，数据类型和类型转换</title>
      <link>http://localhost:1313/post/js%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 26 Jan 2020 21:00:42 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      
        <description>&lt;h2 id=&#34;-let&#34;&gt;推荐阅读：《我用了两个月的时间才理解 let》&lt;/h2&gt;
&lt;h2 id=&#34;heading&#34;&gt;变量声明&lt;/h2&gt;
&lt;p&gt;三种声明方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;var a = 1&lt;/p&gt;
&lt;p&gt;var 过时，不好用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;let a = 1&lt;/p&gt;
&lt;p&gt;let 新的，更合理，用于变量声明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;const a = 1&lt;/p&gt;
&lt;p&gt;const 声明必须赋值，不可更改，用于常量声明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;let-&#34;&gt;let 声明：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;遵循块作用域，使用范围不超过{}。&lt;/li&gt;
&lt;li&gt;不能重复声明。&lt;/li&gt;
&lt;li&gt;可以赋值也可不赋值。&lt;/li&gt;
&lt;li&gt;先声明后使用，否则报错。&lt;/li&gt;
&lt;li&gt;全局声明的 let 变量，不会变成 window 的属性，但是 var 可以。&lt;/li&gt;
&lt;li&gt;for 循环配合 let 有奇效（面试题）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;const-&#34;&gt;const 声明：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;规则几乎跟 let 一样。&lt;/li&gt;
&lt;li&gt;声明时就要赋值，且赋值后不能更改（只读变量，即常量）。&lt;/li&gt;
&lt;li&gt;无法和 for 配合，因为值不可改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;note&#34;&gt;note：变量声明的时候，既指定了值，也指定了类型。&lt;/h3&gt;
&lt;h2 id=&#34;js-&#34;&gt;JS 数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数字 number：
64 位浮点数存储一个 number，其中符号占 1 位，指数占 11 位（-1023~1024），有效数字占 52 位（省略开头的 1）。&lt;/p&gt;
&lt;p&gt;note：正 0，负 0 和 0 是不一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/26/16fe17d7a0e30f31?w=214&amp;amp;h=196&amp;amp;f=png&amp;amp;s=21429&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符串 string：阉割版 UTF8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单引号&amp;rsquo;&amp;rsquo;&lt;/li&gt;
&lt;li&gt;双引号&amp;rdquo;&amp;rdquo;&lt;/li&gt;
&lt;li&gt;反引号``(es6)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;note:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;引号不属于字符串的一部分，例如：
&amp;lsquo;it&#39;s ok&#39;只表示 it 就结束，而&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&#39;it/&#39;s ok&#39;  //转义,表示it&#39;s ok
&amp;quot;it&#39;s ok&amp;quot;
`it&#39;s ok`用反引号`来引用，万能
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;```
\&#39; 表示&#39;
\&amp;quot; 表示&amp;quot;
\\ 表示/
\n 表示换行
\r 表示回车
\t 表示Tab制表符
\uFFFF 表示对应的Unicode字符
\xFF表示前256个Unicode字符
```
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;想在字符串里打会出，可以使用反引号+内容+回车+反引号.&lt;/li&gt;
&lt;li&gt;&#39; &amp;lsquo;字符串长度为 1，空字符串和空格字符串不同。&lt;/li&gt;
&lt;li&gt;UTF-8 是 Unicode 的一种存储规则，也叫字符编码规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;note：数字和字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;功能不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字能加减乘除，字符串不行。&lt;/li&gt;
&lt;li&gt;字符串可以表示电话号码，数字不行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储形式不同:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字：以 64 位浮点数的形式储存。&lt;/li&gt;
&lt;li&gt;字符串：以 UTF8 形式储存。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔 bool： if&amp;hellip;else&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ture：1==1，4&amp;gt;3 等等。&lt;/li&gt;
&lt;li&gt;false：！value，1==2 等等。&lt;/li&gt;
&lt;li&gt;5 个 falsy 值（相当于 false 但又不是 false 的值）：undefined，null，0，NaN 和&amp;rsquo;&#39;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号 symbol：用的很少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空 undefined 和空 null：JS 独创，没有本质区别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;若一个变量声明了，但无赋值，则默认为 undefined 默认。&lt;/li&gt;
&lt;li&gt;而一个函数如果没写 return，则返回值默认为 undefined。&lt;/li&gt;
&lt;li&gt;有人代码习惯上，非对象的空值为 undefined，对象的空值为 null。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对象 object：下一篇单独发布。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;note：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组，函数和日期不是数据类型。&lt;/li&gt;
&lt;li&gt;数组，函数和日期属于 object。&lt;/li&gt;
&lt;li&gt;四基两空一对象。&lt;/li&gt;
&lt;li&gt;undefined，null，number，string，bool，symbol 为简单类型，object 为复杂类型。&lt;/li&gt;
&lt;li&gt;数据类型大小写无所谓。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;类型转换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;number=&amp;gt;string&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String(n)&lt;/li&gt;
&lt;li&gt;n+&amp;rsquo;&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string=&amp;gt;number&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Number（s）&lt;/li&gt;
&lt;li&gt;s - 0&lt;/li&gt;
&lt;li&gt;+s&lt;/li&gt;
&lt;li&gt;parseInt（s）&lt;/li&gt;
&lt;li&gt;parseFloat（s）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x=&amp;gt;bool&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boolean(1)&lt;/li&gt;
&lt;li&gt;!!1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;x=&amp;gt;string - x.toString&lt;/p&gt;
&lt;p&gt;note：js 的 bug
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/26/16fe1d7b91411efe?w=553&amp;amp;h=233&amp;amp;f=png&amp;amp;s=44029&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;js--1&#34;&gt;JS 的奇葩&lt;/h2&gt;
&lt;p&gt;可查看 JS 的秘密花园&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>系统学习HTTP</title>
      <link>http://localhost:1313/post/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0http/</link>
      <pubDate>Fri, 24 Jan 2020 21:28:20 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0http/</guid>
      
        <description>&lt;h3 id=&#34;heading&#34;&gt;体系化学习&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;基础概念（必会的）&lt;/li&gt;
&lt;li&gt;如何调试（用的是 node.js，可以用 log/debugger）&lt;/li&gt;
&lt;li&gt;查资料（node.js 文档）&lt;/li&gt;
&lt;li&gt;标准制定者（HTTP 规格文档：RFC 2612 等）&lt;/li&gt;
&lt;li&gt;CRM 学习法（copy，run，modify）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http-&#34;&gt;HTTP 基础概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;请求&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;请求动词 路径/查询参数 协议名/版本
//以上是请求行
Host：域名或者IP
Accept： 接收内容
Content-type：请求体的格式
//以上为请求头

//请求头和请求体中间要加一个回车
请求体（上传的内容）

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/22/16fcdb66f6ea2883?w=338&amp;amp;h=381&amp;amp;f=png&amp;amp;s=50536&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求格式主要分为：请求行，请求头，请求体。&lt;/li&gt;
&lt;li&gt;请求动词有：GET（获取）/POST（上传）/PUT/PATCH/DELETE 等。&lt;/li&gt;
&lt;li&gt;请求体在 GET 请求中一般为空。&lt;/li&gt;
&lt;li&gt;具体文档&lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html&#34;&gt;RFC 2612 第五章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;大小写随意。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;响应&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;协议名/版本 状态码（默认200） 状态字符串
//以上为状态行
Content-Type：响应体格式（其他一般不用管）
//以上为响应头

//响应头和响应体体中间要加一个回车
响应体（即下载内容）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/22/16fcdbba5db72f39?w=334&amp;amp;h=148&amp;amp;f=png&amp;amp;s=20138&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;响应格式分为状态行，响应头，响应体。&lt;/li&gt;
&lt;li&gt;常见的状态码是考点。&lt;/li&gt;
&lt;li&gt;文档在&lt;a href=&#34;https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html&#34;&gt;RFC 2612 第六章&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>JavaScript语法</title>
      <link>http://localhost:1313/post/javascript%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 20 Jan 2020 23:54:36 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E8%AF%AD%E6%B3%95/</guid>
      
        <description>&lt;h3 id=&#34;heading&#34;&gt;推荐书籍：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你不知道的 JavaScript（先买上卷，适合进阶）&lt;/li&gt;
&lt;li&gt;阮一峰的免费教程&lt;/li&gt;
&lt;li&gt;网道&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;表达式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1+2 表达式的值为 3。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add(1,2）表达式的值为函数的返回值。&lt;/p&gt;
&lt;p&gt;note：值和返回值不一样，只有函数才有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;console.log 表达式的值为函数本身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;console.log(3)表达式的值为 undefined，但会打印出来 3。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;var a = 1 是一个语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达式一般都有值，语句可能有值，也可能没有。&lt;/li&gt;
&lt;li&gt;语句一般会改变环境（声明、赋值）。&lt;/li&gt;
&lt;li&gt;上面两句并不绝对。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;js-&#34;&gt;JS 区分大小写，例如：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;       var a和var A
       object和Object
       function和Function都是不同的含义
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;空格和回车&lt;/h3&gt;
&lt;p&gt;只要不影响断句，空格没有实际意思，回车大部分一样没有实际意思。&lt;/p&gt;
&lt;h4 id=&#34;-return--undefined&#34;&gt;但 return 后不能加回车，否则会返回一个 undefined！！！&lt;/h4&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;标识符&lt;/h3&gt;
&lt;p&gt;变量名，第一个字符可以是 Unicode 字母，$,下划线或者中文。&lt;/p&gt;
&lt;h3 id=&#34;heading-5&#34;&gt;注释&lt;/h3&gt;
&lt;p&gt;/ xxx /只能注释一行，而/_ xxx _/可以注释多行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不好的注释：将代码翻译成中文的注释，无用过时的注释，发泄不满的注释。&lt;/li&gt;
&lt;li&gt;好的注释：踩坑的注释，奇怪的代码和 bug 注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;block-&#34;&gt;block 区块&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;{
  let a = 1;
  let b = 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常与 if，for 和 while 一起用。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;ifelse&#34;&gt;if&amp;hellip;else&amp;hellip;语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(表达式){
    语句 1
   } else {
       语句 2
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{ }在语句只有一句的时候可以省略，不建议这样做。&lt;/li&gt;
&lt;li&gt;if 语句中还可以嵌套 if else，同理 else 中也可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最推荐的写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(表达式){
  语句
}else if(表达式){
  语句
}else{
  语句
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;次推荐的写法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt; function fn(){
  if(表达式){
    return 表达式
  }
  if(表达式){
    return 表达式
  }
    return 表达式
  }
  ```

### switch 语句
不推荐，容易用错。
- 语法：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;a = 2;
switch(a){
case 1：
case 3:
console.log(&amp;lsquo;单数&amp;rsquo;)；
break;
case 2：
case 4：
console.log(&amp;lsquo;双数&amp;rsquo;)；
break；
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- break：
  - 大部分时候，如果要使用switch,一定要记得使用break。
  - 少部分时候，可以利用 break。

### 问号冒号表达式
简洁版的if...else...语句
- 语法：

         表达示1？表达式2：表达式3；

### &amp;amp;&amp;amp;短路逻辑（全真才真）


`A&amp;amp;&amp;amp;B`

若AB都为真，则取B的值，若A为假，则`A&amp;amp;&amp;amp;B`为假，
并不会取 true/false。

### ||短路逻辑（一真就真）

`A||B`
若A为真，则为真。若A为假，则看B，B为真则为真，B为假则为假。
如果能写成||或者&amp;amp;&amp;amp;，就绝对不写 if ...else...语句。

***

### while循环语句

- 语法：


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;while(表达式){
语句
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 首先判断表达式的真假。
2. 当表达式为真，执行语句，执行完再判断表达式的真假。
3. 当表达式为假，执行while后面的语句。



note：

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;var a=0.1
while(a!==1){
console.log(a)
a=a+0.1
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;会出现死循环，这是因为浮点数不精确造成的问题，永远到不了1。

而do...while语句用的不多，自行了解。

### for循环语句

 for是while循环的方便写法

 - 语法

       for（语句1;表达式2;语句3）{
           循环体
       }

1. 先执行语句 1
2. 然后判断表达式 2
3. 如果为真，执行循环体，然后执行语句 3（break可以跳出循环）
4. 如果为假，直接退出循环，执行后面的语句

例如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;for(var i=0;i&amp;lt;5;i++){
setTimeout(()=&amp;gt;{
console.log(i)
})
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;因为setTimeout是过一会时间才打印，过一会，for已经执行完，这时i=5，所以，会打印出五个5。而将var改成let的话，就会打出01234。

### break 和 continue

 - break：退出所有循环

note：break 只会退出离它最近的循环，如果是多for嵌套循环，不会全退。

- continue：退出当前循环

### label 语句


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;foo:{
console.log(1);
break foo;
console.log(&amp;lsquo;本行不会输出&amp;rsquo;);
}
console.log(2);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输出 1 2
- 问：下面的东西是什么？

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;{
a:1;
}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;答：不一个对象，a 是一个 label，它的语句就是一个 1。
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JavaScrip历史及设计缺陷总结</title>
      <link>http://localhost:1313/post/javascrip%E5%8E%86%E5%8F%B2%E5%8F%8A%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 17 Jan 2020 23:26:49 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascrip%E5%8E%86%E5%8F%B2%E5%8F%8A%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h3 id=&#34;js-&#34;&gt;JS 的起源（始于网景）&lt;/h3&gt;
&lt;p&gt;1993 年，伊利诺伊大学厄巴纳-尚佩恩分校的国家超级电脑应用中心（NCSA）发表了 NCSA Mosaic，这是最早流行的图形接口网页浏览器，它在万维网的普及上发挥了重要作用。1994 年，一家名为 Mosaic Communications 的公司在加州芒廷维尤成立了，并雇用了许多原来的 NCSA Mosaic 开发者用来开发 Mosaic Netscape，该公司的目标是取代 NCSA Mosaic 成为世界第一的网页浏览器。第一个版本的网页浏览器 Mosaic Netscape 0.9 于 1994 年底发布。在四个月内，已经占据了四分之三的浏览器市场，并成为 1990 年代互联网的主要浏览器。为避免 NCSA 的商标所有权问题，该浏览器于同年更名为 Netscape Navigator，该公司命名为 Netscape Communications。网景预见到网络需要变得更动态。公司的创始人马克·安德森认为 HTML 需要一种胶水语言，让网页设计师和兼职程序员可以很容易地使用它来组装图片和插件之类的组件，且代码可以直接编写在网页标记中。&lt;/p&gt;
&lt;p&gt;1995 年，网景招募了布兰登·艾克，目标是把 Scheme 语言嵌入到 Netscape Navigator 浏览器当中。但更早之前，网景已经跟昇阳合作在 Netscape Navigator 中支持 Java，这时网景内部产生激烈的争论。后来网景决定发明一种与 Java 搭配使用的辅助脚本语言并且语法上有些类似，这个决策导致排除了采用现有的语言，例如 Perl、Python、Tcl 或 Scheme。为了在其他竞争提案中捍卫 JavaScript 这个想法，公司需要有一个可以运作的原型。艾克在 1995 年 5 月仅花了十天时间就把原型设计出来了。&lt;/p&gt;
&lt;p&gt;最初命名为 Mocha，1995 年 9 月在 Netscape Navigator 2.0 的 Beta 版中改名为 LiveScript，同年 12 月，Netscape Navigator 2.0 Beta 3 中部署时被重命名为 JavaScript，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上 Java 这个编程语言“热词”，因此将其临时改名为 JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。&lt;/p&gt;
&lt;h4 id=&#34;heading&#34;&gt;以上资料来自维基百科&lt;/h4&gt;
&lt;hr&gt;
&lt;h3 id=&#34;js--1&#34;&gt;JS 的设计缺陷&lt;/h3&gt;
&lt;p&gt;以下介绍参考了阮一峰的文章，链接：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&#34;&gt;Javascript 的 10 个设计缺陷&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不适合开发大型程序&lt;/p&gt;
&lt;p&gt;因为 Javascript 没有名称空间（namespace），很难模块化；没有如何将代码分布在多个文件的规范；允许同名函数的重复定义，后面的定义可以覆盖前面的定义，很不利于模块化加载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非常小的标准库&lt;/p&gt;
&lt;p&gt;因为 Javascript 提供的标准函数库非常小，只能完成一些基本操作，很多功能都不具备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;null 和 undefined&lt;/p&gt;
&lt;p&gt;null 属于对象（object）的一种，意思是该对象为空；undefined 则是一种数据类型，表示未定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  typeof null; // object
  typeof undefined; // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两者非常容易混淆，但是含义完全不同，而在编程实践中，null 几乎没用，根本不应该设计它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    var foo;
    alert(foo == null); // true
    alert(foo == undefined); // true
    alert(foo === null); // false
    alert(foo === undefined); // true
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;全局变量难以控制&lt;/p&gt;
&lt;p&gt;Javascript 的全局变量，在所有模块中都是可见的；任何一个函数内部都可以生成全局变量，这大大加剧了程序的复杂性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    a = 1
    (function(){
          b=2;
          alert(a);
          })(); // 1
          alert(b); //2
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;自动插入行尾分号&lt;/p&gt;
&lt;p&gt;Javascript 的所有语句，都必须以分号结尾。但是，如果你忘记加分号，解释器并不报错，而是为你自动加上分号。有时候，这会导致一些难以发现的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如，下面这个函数根本无法达到预期的结果，返回值不是一个对象，而是 undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     function(){
         return
      {
         i=1
      };
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是解释器自动在 return 语句后面加上了分号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     function(){
         return;
     {
         i=1
     };}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;p&gt;加号运算符&lt;/p&gt;
&lt;p&gt;+号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  alert(1+10); // 11

  alert(&amp;quot;1&amp;quot;+&amp;quot;10&amp;quot;); // 110
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个操作项是字符，另一个操作项是数字，则数字自动转化为字符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  alert(1+&amp;quot;10&amp;quot;); // 110

  alert(&amp;quot;10&amp;quot;+1); // 101
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的设计，不必要地加剧了运算的复杂性，完全可以另行设置一个字符连接的运算符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NaN&lt;/p&gt;
&lt;p&gt;NaN 是一种数字，表示超出了解释器的极限。它有一些很奇怪的特性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NaN === NaN; //false

  NaN !== NaN; //true

  alert( 1 + NaN ); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与其设计 NaN，不如解释器直接报错，反而有利于简化程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组和对象的区分&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Javascript 的数组也属于对象（object），所以要区分一个对象到底是不是数组，相当麻烦。Douglas Crockford 的代码是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     if ( arr &amp;amp;&amp;amp;
          typeof arr === &#39;object&#39; &amp;amp;&amp;amp;
          typeof arr.length === &#39;number&#39; &amp;amp;&amp;amp;
          !arr.propertyIsEnumerable(&#39;length&#39;)){
          alert(&amp;quot;arr is an array&amp;quot;);
       }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;== 和 ===&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;==用来判断两个值是否相等。当两个值类型不同时，会发生自动转换，得到的结果非常不符合直觉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     &amp;quot;&amp;quot; == &amp;quot;0&amp;quot; // false

     0 == &amp;quot;&amp;quot; // true

     0 == &amp;quot;0&amp;quot; // true

     false == &amp;quot;false&amp;quot; // false

     false == &amp;quot;0&amp;quot; // true

     false == undefined // false

     false == null // false

     null == undefined // true

     &amp;quot; \t\r\n&amp;quot; == 0 // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，推荐任何时候都使用&amp;quot;===&amp;rdquo;（精确判断）比较符。&lt;/p&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;基本类型的包装对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Javascript 有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     new Boolean(false);
     new Number(1234);
     new String(&amp;quot;Hello World&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与基本数据类型对应的对象类型，作用很小，造成的混淆却很大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     alert( typeof 1234); // number

     alert( typeof new Number(1234)); // object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于 Javascript 的更多怪异行为，请参见 Javascript Garden 和 wtfjs.com。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-javascript-&#34;&gt;既然 Javascript 有缺陷，数量还不少，那么它是不是一种很糟糕的语言？有没有前途？&lt;/h3&gt;
&lt;p&gt;其实 Javascript 并不算糟糕，相反它的编程能力很强大，前途很光明。如果遵守良好的编程规范，加上第三方函数库的帮助，Javascript 的这些缺陷大部分可以回避。&lt;/p&gt;
&lt;p&gt;Javascript 目前是网页编程的唯一语言，只要互联网继续发展，它就必然一起发展。目前，许多新项目大大扩展了它的用途，node.js 使得 Javascript 可以用于后端的服务器编程，coffeeScript 使你可以用 python 和 ruby 的语法，撰写 Javascript。
只要发布新版本的语言标准，就可以弥补这些设计缺陷。当然，标准的发布和标准的实现是两回事，上述的很多缺陷也许会一直伴随到 Javascript 存在的最后一天。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Thu, 16 Jan 2020 00:34:31 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B5%85%E6%9E%90url/</guid>
      
        <description>&lt;h3 id=&#34;ip-internet-protocal&#34;&gt;IP：网际协议，全称 Internet Protocal。&lt;/h3&gt;
&lt;p&gt;主要有两个功能：标识主机或者网络和寻址。
约定了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何定位一台设备。&lt;/li&gt;
&lt;li&gt;如何封装数据报文，以跟其他设备交流。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IP 分为内网和外网。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;-ip&#34;&gt;外网 IP&lt;/h3&gt;
&lt;p&gt;可在 ip138.com 可查看外网 IP，而重启路由器后，可能会重新分配一个外网 IP。&lt;/p&gt;
&lt;h3 id=&#34;-ip-1&#34;&gt;内网 IP&lt;/h3&gt;
&lt;p&gt;一般格式为 192.168.xxx.xxx，一般路由器 IP 为 192.168.1.1。&lt;/p&gt;
&lt;h3 id=&#34;-ip-2&#34;&gt;几个特殊的 IP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;127.0.0.1 表示自己。&lt;/li&gt;
&lt;li&gt;localhost 通过 hosts 指定为自己。&lt;/li&gt;
&lt;li&gt;0.0.0.0 不表示任何设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hosts-&#34;&gt;hosts 文件&lt;/h3&gt;
&lt;p&gt;Windows 系统中，hosts 位于 C:\Windows\System32\drivers\etc\hosts 。在 macOS / Linux 系统中，hosts 位于 /etc/hosts。&lt;/p&gt;
&lt;h3 id=&#34;-port&#34;&gt;端口 Port&lt;/h3&gt;
&lt;p&gt;一台机器可以提供不同服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要提供 HTTP 服务最好使用 80 端口。&lt;/li&gt;
&lt;li&gt;要提供 HTTPS 服务最好使用 433 端口。&lt;/li&gt;
&lt;li&gt;要提供 FTP 服务最好使用 21 端口。&lt;/li&gt;
&lt;li&gt;一共有 65535 个端口。（基本上够用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading&#34;&gt;端口规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;0 到 1023 号端口是留给系统使用的，拥有了管理员权限后，才能使用 0-1023 号端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他端口可以给普通用户使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http-server 默认使用 8080 端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口被占用，只能用另一个端口。&lt;/p&gt;
&lt;h4 id=&#34;ip-&#34;&gt;IP 和端口缺一不可！&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;域名&lt;/h3&gt;
&lt;p&gt;域名可以说是一个 IP 地址的别称，为了便于记忆。&lt;/p&gt;
&lt;p&gt;可以 ping 域名来查看 IP 地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个域名可以对应不同的 IP（负载均衡），大公司常用，可防止一台机器扛不住。&lt;/li&gt;
&lt;li&gt;一个 IP 可以对应不同域名（共享主机），小公司常用，公用服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;域名类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;顶级域名： .com&lt;/li&gt;
&lt;li&gt;二级域名：baidu.com（俗称一级域名）&lt;/li&gt;
&lt;li&gt;三级域名： &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;（俗称二级域名）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;http://www.xxx.com&#34;&gt;www.xxx.com&lt;/a&gt; 和 xxx.com 可能是同一家公司，也可能不是，而且 www 非常多余。&lt;/p&gt;
&lt;h3 id=&#34;dns&#34;&gt;DNS&lt;/h3&gt;
&lt;p&gt;DNS（Domain Name System）将域名和 IP 对应起来。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当你输入 baidu.com 时，你的浏览器会向运营商提供的服务器询问 baidu.com 对应什么 IP&lt;/li&gt;
&lt;li&gt;运营商回复 IP 后，浏览器才会向相应 IP 的 80/433 端口发送请求。&lt;/li&gt;
&lt;li&gt;请求的内容即为 baidu.com 的首页。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;80--443-&#34;&gt;80 或 443 窗口&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;服务器默认使用 80 提供 http 服务。&lt;/li&gt;
&lt;li&gt;服务器默认使用 443 提供 https 服务。&lt;/li&gt;
&lt;li&gt;可在开发者工具里查看具体的端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;路径&lt;/h3&gt;
&lt;p&gt;用于请求不同的页面，路径是没有后缀，在开发者工具 Network 中可查看。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Learn/HTML&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Learn/HTML&lt;/a&gt;
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Learn/CSS&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Learn/CSS&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;查询参数&lt;/h3&gt;
&lt;p&gt;而同一页面，同一路径，也可以显示不同内容，主要取决于查询参数。&lt;/p&gt;
&lt;h3 id=&#34;heading-5&#34;&gt;锚点&lt;/h3&gt;
&lt;p&gt;同一页面，同一查询结果，同一内容的不同位置。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS#&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS#&lt;/a&gt;参考书
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS#&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS#&lt;/a&gt;教程&lt;/p&gt;
&lt;p&gt;notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锚点看起来有中文，但实际不支持中文（通过编码识别）。&lt;/li&gt;
&lt;li&gt;锚点无法在 Network 面板看到，因为锚点不会传给服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;url&#34;&gt;URL&lt;/h3&gt;
&lt;p&gt;完整的 URL 包括&lt;code&gt;[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询参数]#[锚点]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中[访问凭证信息]、[端口号]、[查询参数]、[锚点]都属于选填项。&lt;/p&gt;
&lt;p&gt;HTTPS 默认端口 443，HTTP 默认端口 80。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 13 Jan 2020 22:01:29 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h3 id=&#34;heading&#34;&gt;浏览器渲染过程：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据 HTML 构建 HTML 树（DOM）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文档对象模型(DOM)是 HTML 和 XML 文档的编程接口，它会将 web 页面和脚本或程序语言连接起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据 CSS 构建 CSS 树（CSSOM）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS 对象模型 (CSS Object Model, CSSOM) 是一个存放所有 CSS 选择器与相关特性的树状结构容器，拥有根节点、邻居节点、后代节点、子代节点以及其他关系。 CSSCOM 非常类似于 DOM 文件对象模型 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将两棵树合并成一颗渲染树（render tree）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Layout 布局（文档流，盒模型，计算大小和位置）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Paint 绘制（将边框颜色，文字颜色，阴影等画出来）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compose 合成（根据层叠关系展示画面）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;如何更新样式：&lt;/h3&gt;
&lt;p&gt;一般用 JS 更新样式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;div.style.background=&#39;red&amp;rsquo;&lt;/li&gt;
&lt;li&gt;div.style.display=&#39;none&amp;rsquo;&lt;/li&gt;
&lt;li&gt;div.classList.add(&amp;lsquo;red&amp;rsquo;)（加样式不如加类）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;三种渲染方式和更新方式：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;JS/CSS&amp;gt;样式&amp;gt;布局&amp;gt;绘制&amp;gt;合成&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;例如&lt;code&gt;div.remove()&lt;/code&gt;会触发当前消失，其他元素 relayout。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;JS/CSS&amp;gt;样式&amp;gt;绘制&amp;gt;合成&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;例如改变背景颜色，则直接 repaint+composite。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;JS/CSS&amp;gt;样式&amp;gt;合成&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;改变 transform，只需 composite&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须全屏查看效果，在 iframe 里看问题。&lt;/li&gt;
&lt;li&gt;csstriggers.com 可查看每种属性触发哪些流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;css-&#34;&gt;CSS 动画优化&lt;/h3&gt;
&lt;p&gt;详细可查看&lt;!-- raw HTML omitted --&gt;google 团队文章&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS 优化：使用 requestAnimationFrame 代替 setTimeout 或 setInterval&lt;/li&gt;
&lt;li&gt;CSS 优化：使用 will-change 或 translate&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;transform-&#34;&gt;transform 属性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;四个常用功能&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;位移 transsform&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transsform:translate(50px);&lt;/code&gt;X 轴位移 50 像素。&lt;/p&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若要在 Z 轴（垂直于视点）位移，需要在父元素上添加 perspective 属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transsform:translate(-50%，-50%);&lt;/code&gt;可做绝对定位元素的居中。&lt;/li&gt;
&lt;li&gt;MDN 语法格式很重要！！！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩放 scale：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transsform:scale(1.5)；&lt;/code&gt;
。用的很少，因为变形，容易出现模糊。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转 rotate：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;transsform:rotate(45deg)；&lt;/code&gt;顺时针旋转 45 度。一般用于 360 度旋转制作 loading，或者按钮的交互（鼠标移到按钮上就转一圈），多看 MDN 文档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;倾斜 skew：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;transsform:skewX(15deg)；&lt;/code&gt;X 轴倾斜 15 度。用得较少，用时搜 MDN 文档。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;transition&#34;&gt;transition&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用：补全中间帧。&lt;/p&gt;
&lt;p&gt;例如：
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/13/16f9ee7518795180?w=781&amp;amp;h=397&amp;amp;f=png&amp;amp;s=53303&#34; alt=&#34;&#34;&gt;&lt;!-- raw HTML omitted --&gt;效果&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;transition：属性名 时长 过渡时间 延迟；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transition：right 10s linear；&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可用逗号分隔开两个不同属性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transition：right 10s,top 10s；&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可用 all 代表所有属性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transition：all 10s linear；&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过渡方式：linear，ease，ease-in，ease-out，
ease-in-out，cubic-bezier，step- start，step-end，steps。
具体效果查看&lt;!-- raw HTML omitted --&gt;MDN&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Notes：并非所有属性都使用 transition。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;display:block;=&amp;gt;display:none;不能过渡，而修改成透明度 opacity，也只是看不见了，位置还一直占着。
一般改成 visibility:visible=&amp;gt;hidden，visibility 也是占位置的。&lt;/li&gt;
&lt;li&gt;background 背景颜色可以过渡。&lt;/li&gt;
&lt;li&gt;opacity 透明度可以过渡，但不推荐。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;过渡必须有起始，一般只有一次或两次动画，比如 hover 和非 hover 状态的过渡。&lt;/p&gt;
&lt;p&gt;若有中间过渡，可以使用两次 transform，用 setTimeout 或者监听 transitionend 事件确认中间点。&lt;/p&gt;
&lt;p&gt;也可以使用 animation（声明关键帧，添加动画）来实现。&lt;/p&gt;
&lt;h3 id=&#34;animation&#34;&gt;animation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;keyframes 语法：
一种是 from to:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@keyframes slidein {
  from {
    transform: translateX(0%);
  }

  to {
    transform: translateX(100%);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者百分数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes identifier {
  0% { top: 0; left: 0; }
  30% { top: 50px; }
  68%, 72% { left: 50px; }
  100% { top: 100px; left: 100%; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法：animation:时长|过渡方式|延迟|次数|方向|填充模式|是否暂停|动画名；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时长：1s 或者 1000ms&lt;/li&gt;
&lt;li&gt;过渡方式：跟 transition 取值一样，如 linear&lt;/li&gt;
&lt;li&gt;次数：数字 或着 infinite（无限次）&lt;/li&gt;
&lt;li&gt;方向： - normal：每个循环内动画向前循环，换言之，每个动画循环结束，动画重置到起点重新开始，这是默认属性。 - reverse：反向运行动画，每周期结束动画由尾到头运行。 - alternate：动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为 ease-out。 - alternate-reverse：反向交替，反向开始交替
动画第一次运行时是反向的，然后下一次是正向，后面依次循环。&lt;/li&gt;
&lt;li&gt;填充模式：
&lt;ul&gt;
&lt;li&gt;none：这是默认值，由该元素的 CSS 规则来显示该元素。&lt;/li&gt;
&lt;li&gt;forwards：动画将停留在最后一个关键帧。&lt;/li&gt;
&lt;li&gt;backwards：动画将在应用于目标时立即应用第一个关键帧中定义的值，并在 animation-delay 期间保留此值。第一个关键帧取决于 animation-direction 的值。&lt;/li&gt;
&lt;li&gt;both：动画将遵循 forwards 和 backwards 的规则，从而在两个方向上扩展动画属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是否暂停：
&lt;ul&gt;
&lt;li&gt;paused：当前动画已被停止。&lt;/li&gt;
&lt;li&gt;running：当前动画正在运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;note：以上所有属性都有对应的单独属性。只改一个属性的话就要单独写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS布局和定位</title>
      <link>http://localhost:1313/post/css%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Fri, 10 Jan 2020 19:54:28 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9A%E4%BD%8D/</guid>
      
        <description>&lt;h3 id=&#34;heading&#34;&gt;布局是什么：&lt;/h3&gt;
&lt;p&gt;把页面分成一块一块，按左中右，上中下等排列。&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;布局分类:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;固定宽度布局，例如淘宝网， 一般宽度 960/1000/1024px。&lt;/li&gt;
&lt;li&gt;不固定宽度布局，例如手机端，主要靠文档流原理布局。
文档流本身就是自适应的，不需要额外添加样式。&lt;/li&gt;
&lt;li&gt;响应式布局，pc 上固定宽度，手机上不固定宽度，是一种混合布局。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;布局思路：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从大到小:先定大局，再完善每个小布局。&lt;/li&gt;
&lt;li&gt;从小到大:先完成小布局，再组合成大布局，推荐新手。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;三种布局套路：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;float 布局：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 子元素上加float：left和width。
2. 在父元素上加.clearfix。

例如：

![](https://user-gold-cdn.xitu.io/2020/1/7/16f801aab2022468?w=1279&amp;amp;h=699&amp;amp;f=png&amp;amp;s=116392)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有时最后一个元素不加 width，留些空间，可加上最大宽度&lt;code&gt;max-width：100px；&lt;/code&gt;若加上 width 会出现下图情况:
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f80226f625feb8?w=139&amp;amp;h=51&amp;amp;f=png&amp;amp;s=3749&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不需要做响应式，float 布局专为 IE 准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决 IE6/7 存在双倍 margin 的 bug，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1. 针对IE6/7，把margin减半，如下图，则IE上显示5px乘2，正常浏览器上显示10px：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f803169194f6f8?w=267&amp;amp;h=55&amp;amp;f=png&amp;amp;s=8283&#34; alt=&#34;&#34;&gt; 2. 加一个 display：inline-block； - 若图片下有多余的东西：
添加
&lt;code&gt;vertical-align: top;&lt;/code&gt;
或者&lt;code&gt;vertical-align: middle;&lt;/code&gt;
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f806065bc2dd9d?w=403&amp;amp;h=107&amp;amp;f=png&amp;amp;s=30878&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有时 border 调试会干扰 width，可用 outline 调试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有块级元素且 width 固定，则左右 margin 的 auto 可让元素自动居中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于平均布局，计算出 x，y 的值，必要时中间加一层 div，用到负 margin，值为 y 的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex 布局：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flex container（容器）样式：一般作父元素

 - 让一个元素变成flex容器：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/8/16f8519c00157e08?w=292&amp;amp;h=136&amp;amp;f=png&amp;amp;s=10623&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;justify-content 属性：将 flex 元素与主轴对齐。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start: 元素和容器的左端对齐&lt;/li&gt;
&lt;li&gt;flex-end: 元素和容器的右端对齐&lt;/li&gt;
&lt;li&gt;center: 元素在容器里居中&lt;/li&gt;
&lt;li&gt;space-between:元素之间保持相等的距离&lt;/li&gt;
&lt;li&gt;space-around:元素周围保持相等的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align-items 属性：在交叉轴上对齐多个元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start: 元素与容器的顶部对齐&lt;/li&gt;
&lt;li&gt;flex-end: 元素与容器的底部对齐。&lt;/li&gt;
&lt;li&gt;center: 元素纵向居中&lt;/li&gt;
&lt;li&gt;baseline: 元素在容器的基线位置显示&lt;/li&gt;
&lt;li&gt;stretch: 元素被拉伸以填满整个容器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-direction 属性:决定主轴的方向。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;row: 元素摆放的方向和文字方向一致&lt;/li&gt;
&lt;li&gt;row-reverse: 元素摆放的方向和文字方向相反&lt;/li&gt;
&lt;li&gt;column: 元素从上放到下&lt;/li&gt;
&lt;li&gt;column-reverse: 元素从下放到上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-wrap 属性：定义元素必须在一行，或者自动换行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nowrap: 所有的元素都在一行&lt;/li&gt;
&lt;li&gt;wrap: 元素自动换成多行&lt;/li&gt;
&lt;li&gt;wrap-reverse: 元素自动换成逆序的多行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-flow 属性：
flex-flow 属性包括 flex-direction 和 flex-wrap 两个属性，这个缩写属性接受两个属性的值，两个值中间以空格隔开。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：`flex-flow: row wrap;`设置行并自动换行。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align-content 属性：决定行与行之间的间隔，而 align-items 决定元素整体在容器的什么位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flex-start: 多行都集中在顶部。&lt;/li&gt;
&lt;li&gt;flex-end: 多行都集中在底部。&lt;/li&gt;
&lt;li&gt;center: 多行居中。&lt;/li&gt;
&lt;li&gt;space-between: 行与行之间保持相等距离。&lt;/li&gt;
&lt;li&gt;space-around: 每行的周围保持相等距离。&lt;/li&gt;
&lt;li&gt;stretch: 每一行都被拉伸以填满容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;flex items（项目）样式：一般作子元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/9/16f89d7b43b2400c?w=189&amp;amp;h=186&amp;amp;f=png&amp;amp;s=23768&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;order 属性:决定 flex 元素的顺序，元素的属性默认值为 0，还可设置属性为正数或负数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-grow 属性：决定 flex 元素的拉伸程度，元素的属性默认值为 0，还可设置属性为正数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-shrink 属性：决定了 flex 元素的收缩程度，flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值，属性默认值为 0，还可设置属性为正数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-basis 属性：决定了 flex 元素的基准宽度，如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸，属性默认值为 auto。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex-grow、flex-shrink 和 flex-basis 属性可以缩写，例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  flex-grow: 1;
  flex-shrink: 0;
  flex-basis: 100px;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以写成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  flex： 1 0 100px;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;align-self 属性：在交叉轴上对齐一个元素，其值和 align-items 相同，但会覆盖 align-items 属性值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;-flex--flex--flex-httpsflexboxfroggycomzh-cn&#34;&gt;推荐一款 flex 青蛙游戏，轻松愉快学习 flex 布局，以上 flex 元素属性解释也参考此游戏，详细可访问https://flexboxfroggy.com/#zh-cn。&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;grid 布局：功能最强大的布局方案，但目前兼容性还不好。也分 container 和 items 样式，使用 grid-template-rows 和 grid-template-columns 属性来定义网格的 columns 和 rows，也可使用 grid-column-start, grid-column-end, grid-row-start 和 grid-row-end 属性定位网格线。
例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;.container {
           display: grid;
           grid-template-columns: 1fr 1fr 1fr;
           grid-template-rows: 100px 100px;
         }
.items{
     grid-column-start: 1;
     grid-column-end: 2;
     grid-row-start: 1;
     grid-row-end: 2;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/9/16f8a5ad65608989?w=651&amp;amp;h=335&amp;amp;f=png&amp;amp;s=13874&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;grid-&#34;&gt;grid 尤其适合不规则的布局。&lt;/h4&gt;
&lt;hr&gt;
&lt;h3 id=&#34;css-&#34;&gt;CSS 定位：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;position&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;static：默认值，待在文档流里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;relative：相对定位，未脱离文档流，可在不改变页面布局的前提下调整元素位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现在已经很少用作位移，常用作 absolute 父元素。&lt;/li&gt;
&lt;li&gt;配合 z-index：默认值 auto，不创建新层叠上下文，还可取正负数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;absolute：绝对定位，相对于祖先元素中最近的一个定位元素定位的，定位基准是祖先非 static 的定位元素。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;脱离原来位置，另起一层，如对话框关闭按钮或鼠标提示。&lt;/li&gt;
&lt;li&gt;配合 z-index。&lt;/li&gt;
&lt;li&gt;和 relative 父元素配合使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1.white-space:nowrap;文字内容不准换行。
  2.善用left：100%。
  3.善用left：50%；加负margin。
  4.有些浏览器不写top/left会位置错乱。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fixed：固定定位，定位基准是 viewport，手机上尽量不要用这个属性（坑）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用于烦人的广告或者回到顶部按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配合 z-index。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sticky：沾滞定位，适合导航，目前兼容性很差。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS基础</title>
      <link>http://localhost:1313/post/css%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 06 Jan 2020 16:40:06 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E5%9F%BA%E7%A1%80/</guid>
      
        <description>&lt;h2 id=&#34;-css--mdn-&#34;&gt;今天在谷里学习了 css 基础知识，结合维基百科和 mdn，写下此博客跟大家分享，如有错误之处，欢迎指正（没有奖励 😝）。&lt;/h2&gt;
&lt;h2 id=&#34;heading&#34;&gt;目录：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;css 历史&lt;/li&gt;
&lt;li&gt;体系化学习&lt;/li&gt;
&lt;li&gt;文档流&lt;/li&gt;
&lt;li&gt;盒模型&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;css-&#34;&gt;css 历史&lt;/h3&gt;
&lt;p&gt;css：中文为层叠样式表（又称串样式列表、级联样式表、串接样式表、阶层式样式表）是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，由 W3C 定义和维护。当前使用最广泛的版本是 CSS2.1，为 W3C 的推荐标准。CSS3 现在已被大部分现代浏览器支持，而下一版的 CSS4 仍在开发中。1994 年，哈肯·维姆·莱提出了 CSS 的最初建议。&lt;/p&gt;
&lt;p&gt;层叠:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样式层叠：可以多次对同一选择器进行样式声明。&lt;/li&gt;
&lt;li&gt;选择器层叠：可以用不同选择器对同一个元素进行样式声明。&lt;/li&gt;
&lt;li&gt;文件层叠：可以用多个文件进行层叠。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;note：这些特性使得 css 极度灵活，也为 css 被吐槽留下了隐患。&lt;/p&gt;
&lt;h3 id=&#34;-css21-ie-css3-ie8-&#34;&gt;目前 CSS2.1 为使用最广泛的版本（IE 支持），CSS3 为最新版本（IE8 部分支持）。&lt;/h3&gt;
&lt;p&gt;使用 caniuse.com 检查各种浏览器支持哪些特性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;体系化学习&lt;/h3&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;怎样学习一门语言：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法（怎样写代码）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语法 1：样式语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  选择器{
    属性名:属性值;
    /*注释*/
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notes：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有符号都是英文符号。&lt;/li&gt;
&lt;li&gt;区分大小写。&lt;/li&gt;
&lt;li&gt;没有//注释&lt;/li&gt;
&lt;li&gt;最后一个分号可省略，但建议不要省略。&lt;/li&gt;
&lt;li&gt;任何一个地方写错了，都不会报错，浏览器会忽略。&lt;/li&gt;
&lt;li&gt;若想知道写错，&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法 2:@语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   @charset &amp;quot;UTF-8&amp;quot;;
   @import url(css路径);
   @media (min-width: 100px)and (max-width:200px){
      语法1
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@charset 必须放在第一行。&lt;/li&gt;
&lt;li&gt;前两个@语法都必须以;结尾。&lt;/li&gt;
&lt;li&gt;@media 语法以后在讲。&lt;/li&gt;
&lt;li&gt;charset 是字符集的意思，但 UTF-8 是字符编码 encoding，为历史遗留问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试（查找代码错误）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jigsaw.w3.org/css-validator/&#34;&gt;https://jigsaw.w3.org/css-validator/&lt;/a&gt;将代码粘贴上去即可，不推荐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vscode 颜色报错，位置不大准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WebStorm 看颜色，位置准确。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chrome 开发者工具看警告。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 找到标签
2. 是否有选择器
3. 样式是否被划掉
4. 样式是否被警告
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;Border 调试法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 找到怀疑元素
2. 给该元素加一个border
3. 若border没生效，说明选择器错了或语法错了
4. 若border生效了，看看边界是否符合预期
5. bug解决了删除border
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;note：&lt;/p&gt;
&lt;p&gt;CSS 的 border 调试法相当于 JS 的 log 调试法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;查资料
&lt;ol&gt;
&lt;li&gt;mdn&lt;/li&gt;
&lt;li&gt;css tricks&lt;/li&gt;
&lt;li&gt;张鑫旭博客&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;标准制定者 w3c
&lt;ol&gt;
&lt;li&gt;all css specifications&lt;/li&gt;
&lt;li&gt;css2.1 中文版&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-3&#34;&gt;如何学&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;抄文档，抄老师&lt;/li&gt;
&lt;li&gt;在自己电脑上运行&lt;/li&gt;
&lt;li&gt;加入自己的想法，重新运行并调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;文档流&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流动方向&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inline 元素从左到右，到达最右边才会换行，字节会断开。&lt;/li&gt;
&lt;li&gt;block 元素从上到下，每一个都另起一行。&lt;/li&gt;
&lt;li&gt;inline-block 元素也是从左到右，字节不会断开。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inline 元素默认宽度为内部 inline 元素的和，inline 元素内不能存在 block 元素，不能用 width 指定，白写。&lt;/li&gt;
&lt;li&gt;block 元素默认自动计算宽度，不是也不能写 width:100%;，会出 bug，一般 width 用 px 或者 em 指定。&lt;/li&gt;
&lt;li&gt;inline-block 元素结合两者特点，宽度默认跟 inline 元素一样，但可用 width 指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inline 元素高度由 line-height 间接决定，与 height，padding 无关。&lt;/li&gt;
&lt;li&gt;block 元素高度由内部文档流元素决定，
可以设置 height。&lt;/li&gt;
&lt;li&gt;inline-block 元素跟 block 元素基本类似，可以设置 height。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;overflow
overflow 还可设置 overflow-x 和 overflow-y。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;visibl：默认值。内容不会被剪裁，可以呈现在元素框之外。&lt;/li&gt;
&lt;li&gt;hidden：内容将被剪裁以适合填充框。 不提供滚动条。&lt;/li&gt;
&lt;li&gt;scroll：内容将被剪裁以适合填充框。 浏览器显示滚动条，无论是否实际剪切了任何内容。（这可以防止滚动条在内容更改时出现或消失。）打印机仍可能打印溢出的内容。&lt;/li&gt;
&lt;li&gt;auto：如果内容适合填充框内部，则看起来与可见内容相同。如果内容溢出，桌面浏览器会提供滚动条。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脱离文档流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![](https://user-gold-cdn.xitu.io/2020/1/7/16f7ed138d0d84fe?w=540&amp;amp;h=307&amp;amp;f=png&amp;amp;s=49695)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![](https://user-gold-cdn.xitu.io/2020/1/7/16f7ed38d08b9283?w=533&amp;amp;h=349&amp;amp;f=png&amp;amp;s=52145)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果为：
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f7ed1f8ecf0104?w=272&amp;amp;h=80&amp;amp;f=png&amp;amp;s=5398&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading-5&#34;&gt;盒模型&lt;/h3&gt;
&lt;p&gt;CSS 盒模型有两种，一种是 content-box（内容盒） 一种是 border-box（边框盒）。&lt;/p&gt;
&lt;p&gt;content-box 的宽度 width 表示内容区宽度，不包含 padding 和 border；
而 border-box 的宽度 width 表示内容区 + padding + border 的总和。
一般优先使用后者（border-box）。&lt;/p&gt;
&lt;p&gt;即下图：
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f7ee12704336c8?w=793&amp;amp;h=396&amp;amp;f=png&amp;amp;s=80174&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;margin-&#34;&gt;margin 合并：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个孩子之间的上下 margin 会合并：
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f7eed63dee59b9?w=812&amp;amp;h=354&amp;amp;f=png&amp;amp;s=70930&#34; alt=&#34;&#34;&gt;
css 要求 margin 不用分两个单独写，直接合并就好。
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f7eef242913a14?w=811&amp;amp;h=446&amp;amp;f=png&amp;amp;s=69168&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一个孩子和最后一个孩子的上下 margin，可以和他们的父母合并：
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/7/16f7fcb7e48d3d64?w=1127&amp;amp;h=588&amp;amp;f=png&amp;amp;s=132611&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML重点标签</title>
      <link>http://localhost:1313/post/html%E9%87%8D%E7%82%B9%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 03 Jan 2020 22:14:28 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E9%87%8D%E7%82%B9%E6%A0%87%E7%AD%BE/</guid>
      
        <description>&lt;p&gt;最近两天看了饥人谷的 HTML 网课，结合 mdn 文档写了篇博客，分享给大家。如有错误之处，欢迎指正！（没有奖励 😝）&lt;/p&gt;
&lt;h3 id=&#34;a-&#34;&gt;a 标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;&amp;quot; target=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;heading&#34;&gt;属性：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;href：超链接&lt;/li&gt;
&lt;li&gt;target：打开超链接窗口方式
（http-server -c-1 或着 parcel+文件名来打开 vscode 网址）&lt;/li&gt;
&lt;li&gt;download 下载网页（很多浏览器不支持）&lt;/li&gt;
&lt;li&gt;rel=noopener（防止一个 bug，以后会讲）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;a--href-&#34;&gt;a 的 href 取值：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网址：
&lt;ol&gt;
&lt;li&gt;https://网址&lt;/li&gt;
&lt;li&gt;http://网址&lt;/li&gt;
&lt;li&gt;//网址（最高级，推荐。查看：开发者工具，勾选 preserve log,浏览器自动补全跳转）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路径
&lt;ol&gt;
&lt;li&gt;/a/b/c 以及 a/b/c（当前目录下查找）&lt;/li&gt;
&lt;li&gt;index.com 以及./index.com（都是当前目录下查找）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;伪协议
&lt;ol&gt;
&lt;li&gt;Javascript:;&lt;code&gt;&amp;lt;a href=&amp;quot;Javascript:;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;为了直接执行 js，现在常作点击之后无动作的 a 标签）&lt;/li&gt;
&lt;li&gt;mailto:邮箱&lt;code&gt;&amp;lt;a href=&amp;quot;mailto:573505403@qq.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tel:手机号（简历用）&lt;code&gt;&amp;lt;a href=&amp;quot;tel:17853318194&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;id :&lt;code&gt;&amp;lt;a href=&amp;quot;#xxx&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;（内部锚点，跳转到指定标签位置）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;a--targe-&#34;&gt;a 的 targe 取值：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;内置名字：
&lt;ol&gt;
&lt;li&gt;_blank（在新窗口打开）&lt;/li&gt;
&lt;li&gt;_self（在当前窗口打开）&lt;/li&gt;
&lt;li&gt;_top（在最顶层窗口打开）&lt;/li&gt;
&lt;li&gt;_parent（在父级窗口打开）&lt;/li&gt;
&lt;li&gt;xxx（有 xxx 窗口就使用，没有就在新窗口打开就命名新窗口为 xxx，多链接看效果）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;iframe-&#34;&gt;iframe 标签：&lt;/h3&gt;
&lt;p&gt;内嵌窗口，已经很少使用，现在都用 ajax 方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;table-&#34;&gt;table 标签&lt;/h3&gt;
&lt;p&gt;table 内只能有 thead，tbody，tfoot 标签，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tr：table 一行&lt;/li&gt;
&lt;li&gt;th：table 表头&lt;/li&gt;
&lt;li&gt;td：table 数据
table 三个标签可以不按顺序写，浏览器自动纠正顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-1&#34;&gt;相关样式：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;table-layout：
用于布局单元格，行和列的算法。其属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;auto：浏览器采用自动表格布局算法对表格布局。表格及单元格的宽度取决于其包含的内容。&lt;/li&gt;
&lt;li&gt;fixed：表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;border-collapse：用来决定表格的边框是分开的还是合并的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;collapse：合并，相邻的单元格共用同一条边框。&lt;/li&gt;
&lt;li&gt;separate：分开，默认值。每个单元格拥有独立的边框。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;img-&#34;&gt;img 标签：&lt;/h3&gt;
&lt;p&gt;发出 get 请求，展示一张图片。&lt;/p&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;属性：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;src：必须存在，包含图片的网络地址或文件路径。&lt;/li&gt;
&lt;li&gt;alt：不一定存在，包含对图像的文本描述，加载失败会提示代替的文本。&lt;/li&gt;
&lt;li&gt;weight：只写高度，宽度会自适应。&lt;/li&gt;
&lt;li&gt;height：只写宽度，高度会自适应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;note:永远不要让图片变形！可以只写高度或宽度。&lt;/p&gt;
&lt;h4 id=&#34;js-&#34;&gt;js 事件:&lt;/h4&gt;
&lt;p&gt;onload/onerror:监听图片是否加载成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/3/16f6a81fca1ffd9f?w=275&amp;amp;h=118&amp;amp;f=png&amp;amp;s=31091&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading-3&#34;&gt;响应式：&lt;/h4&gt;
&lt;p&gt;先所有元素 css reset，加句
&lt;code&gt;img{max-width：100%}&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;form-&#34;&gt;form 标签：&lt;/h3&gt;
&lt;p&gt;表单标签，内一般含有输入框和提交按钮（input 标签）。作用：发送一个 get 或 post 请求，然后刷新页面。&lt;/p&gt;
&lt;h4 id=&#34;heading-4&#34;&gt;属性：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;action：处理此表单信息所在的 URL。&lt;/li&gt;
&lt;li&gt;method：可使用 HTTP post 或 get 方式来提交表单。&lt;/li&gt;
&lt;li&gt;autocomplete：浏览器自动填充,使用 on 或 off 来打开或着关闭此功能。&lt;/li&gt;
&lt;li&gt;target：在提交表单之后，在哪个页面显示收到的回复，包括_self，_blank，_top 和_parent。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;事件：&lt;/h4&gt;
&lt;p&gt;onsubmit：用户点击提交按钮后触发。提交按钮可使用 value 更改提交按钮名称。
例如：&lt;code&gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;发射&amp;quot;&amp;gt;&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;code&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;发射&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;发射&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;p&gt;note:两个区别 input 内不能再加其他标签，只能是纯文本，而 button 可以，甚至可以加图片。例如：&lt;code&gt;&amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;&amp;lt;strong&amp;gt;发射&amp;lt;/strong&amp;gt;&amp;lt;/button&amp;gt;&lt;/code&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;发射&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;input-&#34;&gt;input 标签：&lt;/h3&gt;
&lt;p&gt;为了让用户输入内容。&lt;/p&gt;
&lt;h4 id=&#34;heading-6&#34;&gt;常用属性：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;text：单行文本框，默认 type。&lt;/li&gt;
&lt;li&gt;color：颜色控件。&lt;/li&gt;
&lt;li&gt;password：值被遮盖的单行文本字段。&lt;/li&gt;
&lt;li&gt;radio：单选按钮，name 属性使用同一个值可实现二选一。&lt;/li&gt;
&lt;li&gt;checkbox：多选按钮，name 属性使用同一个值，使其在同一数组中。&lt;/li&gt;
&lt;li&gt;file：选择文件，多选文件可添加 multiple 属性。&lt;/li&gt;
&lt;li&gt;hidden：隐藏的控件，用于 js 自动填入 id，字符串之类的。&lt;/li&gt;
&lt;li&gt;image：图片提交按钮。可以使用 height 和 width 属性定义图片的大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;事件：&lt;/h4&gt;
&lt;p&gt;onchange：用户输入改变时触发。
onfocus：用户鼠标集中时触发。
onblur：用户鼠标离开时触发。&lt;/p&gt;
&lt;h4 id=&#34;heading-8&#34;&gt;验证器：&lt;/h4&gt;
&lt;p&gt;HTML5 新增功能。例如必须提交文本：&lt;code&gt;&amp;lt;input type=&amp;quot;text&amp;quot; required&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;heading-9&#34;&gt;注意事项：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一般不监听input的click事件。&lt;/li&gt;
&lt;li&gt;form内的input要有name。&lt;/li&gt;
&lt;li&gt;form内放一个type=submit才能触发submit事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;heading-10&#34;&gt;其他标签:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;textarea：多行文本框。固定文本框大小可用&lt;code&gt;&amp;lt;textarea style=&amp;quot;resize: none;&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;&lt;/code&gt;具体大小可用 width，height 属性固定。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;select:选择标签，例如：
&lt;code&gt;&amp;lt;select&amp;gt;&amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;周一&amp;lt;/option&amp;gt;&amp;lt;option value=&amp;quot;1&amp;quot;&amp;gt;周二&amp;lt;/option&amp;gt;&amp;lt;/select&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;请选择&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;周一&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;周二&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>使用hugo搭建个人博客mac版</title>
      <link>http://localhost:1313/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2mac%E7%89%88/</link>
      <pubDate>Wed, 01 Jan 2020 22:15:24 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2mac%E7%89%88/</guid>
      
        <description>&lt;h2 id=&#34;-hugo-&#34;&gt;大家好，今天给大家分享下如何使用 hugo 搭建个人博客&lt;/h2&gt;
&lt;h3 id=&#34;1-hugo&#34;&gt;1.安装 hugo&lt;/h3&gt;
&lt;p&gt;在终端中输入
&lt;code&gt;brew install hugo&lt;/code&gt;安装。&lt;/p&gt;
&lt;p&gt;安装成功后可输入&lt;code&gt;hugo version&lt;/code&gt;查看版本信息。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2&#34;&gt;2.创建新网址&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo new site quickstart&lt;/code&gt;
其中&lt;code&gt;quickstart&lt;/code&gt;更改为&lt;code&gt;用户名.github.io-creator&lt;/code&gt;（用户名为 github 用户名，需要小写）
使用&lt;code&gt;code 用户名.github.io-creator&lt;/code&gt;使用 vscode 查看目录&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3&#34;&gt;3.添加一个主题&lt;/h3&gt;
&lt;p&gt;在 vscode 目录下打开新的终端，输入
&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后，将默认主题添加到站点配置中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还可自定义主题，具体可浏览&lt;!-- raw HTML omitted --&gt;hugo&lt;!-- raw HTML omitted --&gt;官网查看教程。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4&#34;&gt;4.添加一些文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo new posts/my-first-post.md&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;my-first-post&lt;/code&gt;可更改博客名。
可从下图内容后编辑
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/4/16f707cfef95191f?w=315&amp;amp;h=90&amp;amp;f=png&amp;amp;s=10148&#34; alt=&#34;&#34;&gt;
并将&lt;code&gt;draft：ture&lt;/code&gt;更改为&lt;code&gt;draft：false&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;5-hugo-&#34;&gt;5.启动 Hugo 服务器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo server -D&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;6&#34;&gt;6.建立静态页面&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;hugo -D&lt;/code&gt;
自动创建一个 public 目录。&lt;/p&gt;
&lt;h3 id=&#34;7-github&#34;&gt;7.上传至 github&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 vscode 新建一个.gitignore，进入后输入
&lt;img src=&#34;https://user-gold-cdn.xitu.io/2020/1/4/16f7090c28139a8a?w=276&amp;amp;h=107&amp;amp;f=png&amp;amp;s=4268&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终端下输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd public/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add .&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit -v&lt;/code&gt;备注后关闭，第一篇文章就部署完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 github 上新建仓库，名称为：&lt;code&gt;用户名.github.io&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;终端中输入
&lt;code&gt;git remote add origin git@github.com:github用户名/用户名.github.io.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;后，刷新页面即可&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在 github settings 中找到 GitHub Pages，点击&lt;code&gt;https://github用户名.github.io/&lt;/code&gt;即可&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
  </channel>
</rss>
